{"version":3,"sources":["../../src/evaluators/buildOptions.ts"],"names":["buildOptions","filename","options","plugins","defaults","caller","name","evaluate","presets","require","resolve","map","babelOptions","keys","forEach","field","filter","item","Array","isArray","includes","some","it"],"mappings":";;;;;;;AAAA;AACA;AACA;AAWe,SAASA,YAAT,CACbC,QADa,EAEbC,OAFa,EAGK;AAClB,QAAMC,OAA+B,GAAG,CACtC;AACA,4CAFsC,EAGtC,8CAHsC,CAAxC;AAMA,QAAMC,QAAwB,GAAG;AAC/BC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,IAAI,EAAE,SAAR;AAAmBC,MAAAA,QAAQ,EAAE;AAA7B,KADuB;AAE/BN,IAAAA,QAAQ,EAAEA,QAFqB;AAG/BO,IAAAA,OAAO,EAAE,CACP,CACEC,OAAO,CAACC,OAAR,CAAgB,UAAhB,CADF,EAEE,EACE,IAAIR,OAAO,IAAI,EAAf;AADF,KAFF,CADO,CAHsB;AAW/BC,IAAAA,OAAO,EAAE,CACP,GAAGA,OAAO,CAACQ,GAAR,CAAaL,IAAD,IAAUG,OAAO,CAACC,OAAR,CAAgBJ,IAAhB,CAAtB,CADI,EAEP;AACA;AACAG,IAAAA,OAAO,CAACC,OAAR,CAAgB,wBAAhB,CAJO;AAXsB,GAAjC;AAmBA,QAAME,YAAY,GAChB;AACAV,EAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,IAAAA,OAAO,CAAEU,YAAT,GAAwB,EAAE,GAAGV,OAAO,CAACU;AAAb,GAAxB,GAAsD,EAFxD,CA1BkB,CA8BlB;AACA;AACA;;AACA,QAAMC,IAA6D,GAAG,CACpE,SADoE,EAEpE,SAFoE,CAAtE;AAIAA,EAAAA,IAAI,CAACC,OAAL,CAAcC,KAAD,IAAW;AACtBH,IAAAA,YAAY,CAACG,KAAD,CAAZ,GAAsBH,YAAY,CAACG,KAAD,CAAZ,GAClBH,YAAY,CAACG,KAAD,CAAZ,CAAqBC,MAArB,CAA6BC,IAAD,IAAsB;AAChD;AACA;AACA;AACA,YAAMX,IAAI,GAAGY,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAI,CAAC,CAAD,CAA1B,GAAgCA,IAA7C;;AAEA,WACE;AACA;AACA;AACA;AACAX,MAAAA,IAAI,KAAK,eAAT,IACAA,IAAI,KAAK,UADT,IAEAA,IAAI,KAAK,uBAFT,IAGAA,IAAI,KAAKG,OAAO,CAACC,OAAR,CAAgB,UAAhB,CAHT,IAIA;AACAP,MAAAA,OAAO,CAACiB,QAAR,CAAiBd,IAAjB,CAVF,EAWE;AACA,eAAO,KAAP;AACD,OAnB+C,CAqBhD;;;AACA,aAAO,CAACF,QAAQ,CAACW,KAAD,CAAR,CAAgBM,IAAhB,CAAsBC,EAAD,IAC3B;AACAJ,MAAAA,KAAK,CAACC,OAAN,CAAcG,EAAd,IAAoBA,EAAE,CAAC,CAAD,CAAF,KAAUhB,IAA9B,GAAqCgB,EAAE,KAAKhB,IAFtC,CAAR;AAID,KA1BD,CADkB,GA4BlB,EA5BJ;AA6BD,GA9BD;AAgCA,SAAO,EACL;AACA;AACA,OAAGM,YAHE;AAIL,OAAGR,QAJE;AAKLI,IAAAA,OAAO,EAAE,CACP;AACA;AACA,OAAGI,YAAY,CAACJ,OAHT,EAIP,GAAGJ,QAAQ,CAACI,OAJL,CALJ;AAWLL,IAAAA,OAAO,EAAE,CACP,GAAGC,QAAQ,CAACD,OADL,EAEP;AACA;AACA,OAAGS,YAAY,CAACT,OAJT;AAXJ,GAAP;AAkBD","sourcesContent":["/**\n * This file handles preparing babel config for Linaria preevaluation.\n */\n\nimport type { PluginItem, TransformOptions } from '@babel/core';\nimport type { StrictOptions } from '../types';\n\ntype DefaultOptions = Partial<TransformOptions> & {\n  plugins: PluginItem[];\n  presets: PluginItem[];\n  caller: { evaluate: boolean };\n};\n\nexport default function buildOptions(\n  filename: string,\n  options?: StrictOptions\n): TransformOptions {\n  const plugins: Array<string | object> = [\n    // Include these plugins to avoid extra config when using { module: false } for webpack\n    '@babel/plugin-transform-modules-commonjs',\n    '@babel/plugin-proposal-export-namespace-from',\n  ];\n\n  const defaults: DefaultOptions = {\n    caller: { name: 'linaria', evaluate: true },\n    filename: filename,\n    presets: [\n      [\n        require.resolve('../index'),\n        {\n          ...(options || {}),\n        },\n      ],\n    ],\n    plugins: [\n      ...plugins.map((name) => require.resolve(name as string)),\n      // We don't support dynamic imports when evaluating, but don't wanna syntax error\n      // This will replace dynamic imports with an object that does nothing\n      require.resolve('../dynamic-import-noop'),\n    ],\n  };\n\n  const babelOptions =\n    // Shallow copy the babel options because we mutate it later\n    options?.babelOptions ? { ...options.babelOptions } : {};\n\n  // If we programmatically pass babel options while there is a .babelrc, babel might throw\n  // We need to filter out duplicate presets and plugins so that this doesn't happen\n  // This workaround isn't full proof, but it's still better than nothing\n  const keys: Array<keyof TransformOptions & ('presets' | 'plugins')> = [\n    'presets',\n    'plugins',\n  ];\n  keys.forEach((field) => {\n    babelOptions[field] = babelOptions[field]\n      ? babelOptions[field]!.filter((item: PluginItem) => {\n          // If item is an array it's a preset/plugin with options ([preset, options])\n          // Get the first item to get the preset.plugin name\n          // Otherwise it's a plugin name (can be a function too)\n          const name = Array.isArray(item) ? item[0] : item;\n\n          if (\n            // In our case, a preset might also be referring to linaria/babel\n            // We require the file from internal path which is not the same one that we export\n            // This case won't get caught and the preset won't filtered, even if they are same\n            // So we add an extra check for top level linaria/babel\n            name === 'linaria/babel' ||\n            name === '@linaria' ||\n            name === '@linaria/babel-preset' ||\n            name === require.resolve('../index') ||\n            // Also add a check for the plugin names we include for bundler support\n            plugins.includes(name)\n          ) {\n            return false;\n          }\n\n          // Loop through the default presets/plugins to see if it already exists\n          return !defaults[field].some((it) =>\n            // The default presets/plugins can also have nested arrays,\n            Array.isArray(it) ? it[0] === name : it === name\n          );\n        })\n      : [];\n  });\n\n  return {\n    // Passed options shouldn't be able to override the options we pass\n    // Linaria's plugins rely on these (such as filename to generate consistent hash)\n    ...babelOptions,\n    ...defaults,\n    presets: [\n      // Preset order is last to first, so add the extra presets to start\n      // This makes sure that our preset is always run first\n      ...babelOptions.presets!,\n      ...defaults.presets,\n    ],\n    plugins: [\n      ...defaults.plugins,\n      // Plugin order is first to last, so add the extra presets to end\n      // This makes sure that the plugins we specify always run first\n      ...babelOptions.plugins!,\n    ],\n  };\n}\n"],"file":"buildOptions.js"}