import { createHash } from 'crypto';
import { debug } from '@linaria/logger';
const fileHashes = new Map();
const evalCache = new Map();
const fileKeys = new Map();

const hash = text => createHash('sha1').update(text).digest('base64');

let lastText = '';
let lastHash = hash(lastText);

const memoizedHash = text => {
  if (lastText !== text) {
    lastHash = hash(text);
    lastText = text;
  }

  return lastHash;
};

const toKey = (filename, exports) => exports.length > 0 ? `${filename}:${exports.join(',')}` : filename;

export const clear = () => {
  fileHashes.clear();
  evalCache.clear();
  fileKeys.clear();
};
export const clearForFile = filename => {
  const keys = fileKeys.get(filename) ?? [];

  if (keys.length === 0) {
    return;
  }

  debug('eval-cache:clear-for-file', filename);

  for (const key of keys) {
    fileHashes.delete(key);
    evalCache.delete(key);
  }

  fileKeys.set(filename, []);
};
export const has = ([filename, ...exports], text) => {
  const key = toKey(filename, exports);
  const textHash = memoizedHash(text);
  debug('eval-cache:has', `${key} ${textHash}`);
  return fileHashes.get(key) === textHash;
};
export const get = ([filename, ...exports], text) => {
  const key = toKey(filename, exports);
  const textHash = memoizedHash(text);
  debug('eval-cache:get', `${key} ${textHash}`);

  if (fileHashes.get(key) !== textHash) {
    return undefined;
  }

  return evalCache.get(key);
};
export const set = ([filename, ...exports], text, value) => {
  const key = toKey(filename, exports);
  const textHash = memoizedHash(text);
  debug('eval-cache:set', `${key} ${textHash}`);
  fileHashes.set(key, textHash);
  evalCache.set(key, value);

  if (!fileKeys.has(filename)) {
    fileKeys.set(filename, []);
  }

  fileKeys.get(filename).push(key);
};
//# sourceMappingURL=eval-cache.js.map