{"version":3,"sources":["../../../src/evaluators/visitors/JSXElement.ts"],"names":["types","t","getFunctionName","path","isClassMethod","isIdentifier","node","key","name","JSXElement","emptyFragment","jsxFragment","jsxOpeningFragment","jsxClosingFragment","scopePath","scope","isFunction","emptyBody","blockStatement","returnStatement","decl","findParent","p","isClassDeclaration","replaceWith","functionDeclaration","id","body","get","Array","isArray","Error","params"],"mappings":"AAAA,SAASA,KAAK,IAAIC,CAAlB,QAA2B,aAA3B;;AAIA,SAASC,eAAT,CAAyBC,IAAzB,EAAkE;AAChE,MAAIA,IAAI,CAACC,aAAL,MAAwBH,CAAC,CAACI,YAAF,CAAeF,IAAI,CAACG,IAAL,CAAUC,GAAzB,CAA5B,EAA2D;AACzD,WAAOJ,IAAI,CAACG,IAAL,CAAUC,GAAV,CAAcC,IAArB;AACD;;AAED,SAAO,IAAP;AACD;;AAED,eAAe,SAASC,UAAT,CAAoBN,IAApB,EAAoD;AACjE;AACA,QAAMO,aAAa,GAAGT,CAAC,CAACU,WAAF,CACpBV,CAAC,CAACW,kBAAF,EADoB,EAEpBX,CAAC,CAACY,kBAAF,EAFoB,EAGpB,EAHoB,CAAtB,CAFiE,CAQjE;AACA;;AACA,QAAMC,SAAS,GAAGX,IAAI,CAACY,KAAL,CAAWZ,IAA7B;;AACA,MAAIW,SAAS,CAACE,UAAV,EAAJ,EAA4B;AAC1B,UAAMC,SAAS,GAAGhB,CAAC,CAACiB,cAAF,CAAiB,CAACjB,CAAC,CAACkB,eAAF,CAAkBT,aAAlB,CAAD,CAAjB,CAAlB,CAD0B,CAG1B;;AACA,QAAIR,eAAe,CAACY,SAAD,CAAf,KAA+B,QAAnC,EAA6C;AAC3C,YAAMM,IAAI,GAAGN,SAAS,CAACO,UAAV,CAAsBC,CAAD,IAAOA,CAAC,CAACC,kBAAF,EAA5B,CAAb,CAD2C,CAG3C;;AACA,UAAIH,IAAI,EAAEG,kBAAN,EAAJ,EAAgC;AAC9BH,QAAAA,IAAI,CAACI,WAAL,CAAiBvB,CAAC,CAACwB,mBAAF,CAAsBL,IAAI,CAACd,IAAL,CAAUoB,EAAhC,EAAoC,EAApC,EAAwCT,SAAxC,CAAjB;AAEA;AACD;AACF;;AAED,UAAMU,IAAI,GAAGb,SAAS,CAACc,GAAV,CAAc,MAAd,CAAb;;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAJ,EAAyB;AACvB,YAAM,IAAII,KAAJ,CACH,6JADG,CAAN;AAGD;;AAED,UAAMzB,IAA2B,GAAG,EAClC,GAAGQ,SAAS,CAACR,IADqB;AAElCqB,MAAAA,IAAI,EAAEV,SAF4B;AAGlCe,MAAAA,MAAM,EAAE;AAH0B,KAApC;AAMAlB,IAAAA,SAAS,CAACU,WAAV,CAAsBlB,IAAtB;AACD,GA7BD,MA6BO;AACLH,IAAAA,IAAI,CAACqB,WAAL,CAAiBd,aAAjB;AACD;AACF","sourcesContent":["import { types as t } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type { Function, JSXElement as JSXElementNode } from '@babel/types';\n\nfunction getFunctionName(path: NodePath<Function>): string | null {\n  if (path.isClassMethod() && t.isIdentifier(path.node.key)) {\n    return path.node.key.name;\n  }\n\n  return null;\n}\n\nexport default function JSXElement(path: NodePath<JSXElementNode>) {\n  // JSX can be safely replaced on an empty fragment because it is unnecessary for styles\n  const emptyFragment = t.jsxFragment(\n    t.jsxOpeningFragment(),\n    t.jsxClosingFragment(),\n    []\n  );\n\n  // We can do even more\n  // If that JSX is a result of a function, we can replace the function body.\n  const scopePath = path.scope.path;\n  if (scopePath.isFunction()) {\n    const emptyBody = t.blockStatement([t.returnStatement(emptyFragment)]);\n\n    // Is it not just a function, but a method `render`?\n    if (getFunctionName(scopePath) === 'render') {\n      const decl = scopePath.findParent((p) => p.isClassDeclaration());\n\n      // Replace the whole component\n      if (decl?.isClassDeclaration()) {\n        decl.replaceWith(t.functionDeclaration(decl.node.id, [], emptyBody));\n\n        return;\n      }\n    }\n\n    const body = scopePath.get('body');\n    if (Array.isArray(body)) {\n      throw new Error(\n        `A body of a function is expected to be a single element but an array was returned. It's possible if JS syntax has been changed since that code was written.`\n      );\n    }\n\n    const node: typeof scopePath.node = {\n      ...scopePath.node,\n      body: emptyBody,\n      params: [],\n    };\n\n    scopePath.replaceWith(node);\n  } else {\n    path.replaceWith(emptyFragment);\n  }\n}\n"],"file":"JSXElement.js"}