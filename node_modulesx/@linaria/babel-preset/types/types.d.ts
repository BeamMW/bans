import type { Node, Expression, TaggedTemplateExpression } from '@babel/types';
import type { TransformOptions } from '@babel/core';
import type { NodePath } from '@babel/traverse';
import type { StyledMeta } from '@linaria/core';
import type { RawSourceMap } from 'source-map';
import type { PluginOptions } from './utils/loadOptions';
export declare type JSONValue = string | number | boolean | JSONObject | JSONArray;
export interface JSONObject {
    [x: string]: JSONValue;
}
export interface JSONArray extends Array<JSONValue> {
}
export declare type Serializable = JSONArray | JSONObject;
export declare enum ValueType {
    COMPONENT = 0,
    LAZY = 1,
    FUNCTION = 2,
    VALUE = 3
}
export declare type Value = Function | StyledMeta | string | number;
export declare type ValueCache = Map<Expression | string, Value>;
export declare type ComponentValue = {
    kind: ValueType.COMPONENT;
    ex: NodePath<Expression> | Expression | string;
};
export declare type LazyValue = {
    kind: ValueType.LAZY;
    ex: NodePath<Expression> | Expression | string;
    originalEx: NodePath<Expression> | Expression | string;
};
export declare type FunctionValue = {
    kind: ValueType.FUNCTION;
    ex: any;
};
export declare type EvaluatedValue = {
    kind: ValueType.VALUE;
    value: Value;
};
export declare type ExpressionValue = ComponentValue | LazyValue | FunctionValue | EvaluatedValue;
export declare type TemplateExpression = {
    styled?: {
        component: any;
    };
    path: NodePath<TaggedTemplateExpression>;
    expressionValues: ExpressionValue[];
};
declare type Rules = {
    [selector: string]: {
        className: string;
        displayName: string;
        cssText: string;
        start: Location | null | undefined;
        atom?: boolean;
    };
};
declare type Replacements = Array<{
    original: {
        start: Location;
        end: Location;
    };
    length: number;
}>;
declare type Dependencies = string[];
export declare type State = {
    queue: TemplateExpression[];
    rules: Rules;
    replacements: Replacements;
    index: number;
    dependencies: Dependencies;
    file: {
        opts: {
            cwd: string;
            root: string;
            filename: string;
        };
        metadata: {
            localName?: string;
            linaria?: {
                rules: Rules;
                replacements: Replacements;
                dependencies: Dependencies;
            };
        };
    };
};
export declare type Evaluator = (filename: string, options: StrictOptions, text: string, only: string[] | null) => [string, Map<string, string[]> | null];
export declare type EvalRule = {
    test?: RegExp | ((path: string) => boolean);
    action: Evaluator | 'ignore' | string;
};
export declare type ClassNameSlugVars = {
    hash: string;
    title: string;
    file: string;
    ext: string;
    name: string;
    dir: string;
};
declare type ClassNameFn = (hash: string, title: string, args: ClassNameSlugVars) => string;
declare type AtomizeFn = (cssText: string) => {
    className: string;
    cssText: string;
    property: string;
}[];
export declare type StrictOptions = {
    classNameSlug?: string | ClassNameFn;
    displayName: boolean;
    evaluate: boolean;
    ignore?: RegExp;
    atomize?: AtomizeFn;
    babelOptions: TransformOptions;
    rules: EvalRule[];
};
export declare type Location = {
    line: number;
    column: number;
};
export declare type Replacement = {
    original: {
        start: Location;
        end: Location;
    };
    length: number;
};
export declare type Result = {
    code: string;
    sourceMap?: RawSourceMap | null;
    cssText?: string;
    cssSourceMapText?: string;
    dependencies?: string[];
    rules?: Rules;
    replacements?: Replacement[];
};
export declare type LinariaMetadata = {
    rules: Rules;
    replacements: Replacement[];
    dependencies: string[];
};
export declare type Options = {
    filename: string;
    preprocessor?: Preprocessor;
    outputFilename?: string;
    inputSourceMap?: RawSourceMap;
    pluginOptions?: Partial<PluginOptions>;
};
export declare type PreprocessorFn = (selector: string, cssText: string) => string;
export declare type Preprocessor = 'none' | 'stylis' | PreprocessorFn | void;
declare type AllNodes = {
    [T in Node['type']]: Extract<Node, {
        type: T;
    }>;
};
declare module '@babel/types' {
    type VisitorKeys = {
        [T in keyof AllNodes]: Extract<keyof AllNodes[T], {
            [Key in keyof AllNodes[T]]: AllNodes[T][Key] extends Node | Node[] | null ? Key : never;
        }[keyof AllNodes[T]]>;
    };
}
export {};
