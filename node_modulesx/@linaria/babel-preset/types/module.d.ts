/**
 * This is a custom implementation for the module system for evaluating code,
 * used for resolving values for dependencies interpolated in `css` or `styled`.
 *
 * This serves 2 purposes:
 * - Avoid leakage from evaluated code to module cache in current context, e.g. `babel-register`
 * - Allow us to invalidate the module cache without affecting other stuff, necessary for rebuilds
 *
 * We also use it to transpile the code with Babel by default.
 * We also store source maps for it to provide correct error stacktraces.
 *
 */
import type { BabelFileResult } from '@babel/core';
import { debug } from '@linaria/logger';
import type { StrictOptions } from './types';
declare let cache: {
    [id: string]: Module;
};
declare class Module {
    static invalidate: () => void;
    static invalidateEvalCache: () => void;
    static _resolveFilename: (id: string, options: {
        id: string;
        filename: string;
        paths: string[];
    }) => string;
    static _nodeModulePaths: (filename: string) => string[];
    id: string;
    filename: string;
    options: StrictOptions;
    imports: Map<string, string[]> | null;
    paths: string[];
    exports: any;
    extensions: string[];
    dependencies: string[] | null;
    transform: ((text: string) => BabelFileResult | null) | null;
    debug: typeof debug;
    debuggerDepth: number;
    constructor(filename: string, options: StrictOptions, debuggerDepth?: number);
    resolve: (rawId: string) => string;
    require: {
        (id: string): any;
        resolve: (id: string) => string;
        ensure: () => void;
        cache: typeof cache;
    };
    evaluate(text: string, only?: string[] | null): void;
}
export default Module;
