{"version":3,"sources":["../src/identifierHandlers.ts"],"names":["types","t","peek","identifierHandlers","core","ScopeManager","handlers","isAlias","type","FLIPPED_ALIAS_KEYS","defineHandler","typeOrAlias","field","handler","forEach","batchDefineHandlers","typesAndFields","fields","declare","keep","refer","builder","node","scope","memberExpressionObjectHandler","context","declaration","addReference","graph","addEdge","globalExportsIdentifier","globalModuleIdentifier","memberExpressionPropertyHandler","parent","isMemberExpression","computed"],"mappings":"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","sourcesContent":["import { types as t } from '@babel/core';\nimport type { Aliases, Identifier, Node, VisitorKeys } from '@babel/types';\nimport { peek } from '@linaria/babel-preset';\nimport GraphBuilderState from './GraphBuilderState';\nimport type { IdentifierHandlerType, NodeType } from './types';\nimport { identifierHandlers as core } from './langs/core';\nimport ScopeManager from './scope';\n\ntype HandlerFn = <TParent extends Node = Node>(\n  builder: GraphBuilderState,\n  node: Identifier,\n  parent: TParent,\n  parentKey: VisitorKeys[TParent['type']],\n  listIdx: number | null\n) => void;\n\ntype Handler = IdentifierHandlerType | HandlerFn;\n\nconst handlers: {\n  [key: string]: Handler;\n} = {};\n\nfunction isAlias(type: NodeType): type is keyof Aliases {\n  return type in t.FLIPPED_ALIAS_KEYS;\n}\n\nexport function defineHandler(\n  typeOrAlias: NodeType,\n  field: string,\n  handler: Handler\n) {\n  const types = isAlias(typeOrAlias)\n    ? t.FLIPPED_ALIAS_KEYS[typeOrAlias]\n    : [typeOrAlias];\n  types.forEach((type: string) => {\n    handlers[`${type}:${field}`] = handler;\n  });\n}\n\nexport function batchDefineHandlers(\n  typesAndFields: [NodeType, ...string[]][],\n  handler: IdentifierHandlerType\n) {\n  typesAndFields.forEach(([type, ...fields]) =>\n    fields.forEach((field) => defineHandler(type, field, handler))\n  );\n}\n\nbatchDefineHandlers([...core.declare], 'declare');\n\nbatchDefineHandlers([...core.keep], 'keep');\n\nbatchDefineHandlers([...core.refer], 'refer');\n\n/*\n * Special case for FunctionDeclaration\n * Function id should be defined in the parent scope\n */\ndefineHandler(\n  'FunctionDeclaration',\n  'id',\n  (builder: GraphBuilderState, node: Identifier) => {\n    builder.scope.declare(node, false, null, 1);\n  }\n);\n\n/*\n * Special handler for [obj.member = 42] = [1] in different contexts\n */\nconst memberExpressionObjectHandler = (\n  builder: GraphBuilderState,\n  node: Identifier\n) => {\n  const context = peek(builder.context);\n  const declaration = builder.scope.addReference(node);\n  if (declaration) {\n    builder.graph.addEdge(node, declaration);\n\n    if (context === 'lval') {\n      // One exception here: we shake exports,\n      // so `exports` does not depend on its members' assignments.\n      if (\n        declaration !== ScopeManager.globalExportsIdentifier &&\n        declaration !== ScopeManager.globalModuleIdentifier\n      ) {\n        builder.graph.addEdge(declaration, node);\n      }\n    }\n  }\n};\n\ndefineHandler('MemberExpression', 'object', memberExpressionObjectHandler);\ndefineHandler(\n  'OptionalMemberExpression',\n  'object',\n  memberExpressionObjectHandler\n);\n\n/*\n * Special handler for obj.member and obj[member]\n */\nconst memberExpressionPropertyHandler = (\n  builder: GraphBuilderState,\n  node: Identifier,\n  parent: Node\n) => {\n  if (t.isMemberExpression(parent) && parent.computed) {\n    const declaration = builder.scope.addReference(node);\n    // Let's check that it's not a global variable\n    if (declaration) {\n      // usage of a variable depends on its declaration\n      builder.graph.addEdge(node, declaration);\n\n      const context = peek(builder.context);\n      if (context === 'lval') {\n        // This is an identifier in the left side of an assignment expression and a variable value depends on that.\n        builder.graph.addEdge(declaration, node);\n      }\n    }\n  }\n};\n\ndefineHandler('MemberExpression', 'property', memberExpressionPropertyHandler);\ndefineHandler(\n  'OptionalMemberExpression',\n  'property',\n  memberExpressionPropertyHandler\n);\n\nexport default handlers;\n"],"file":"identifierHandlers.js"}