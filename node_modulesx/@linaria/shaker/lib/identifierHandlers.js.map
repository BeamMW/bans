{"version":3,"sources":["../src/identifierHandlers.ts"],"names":["handlers","isAlias","type","t","FLIPPED_ALIAS_KEYS","defineHandler","typeOrAlias","field","handler","types","forEach","batchDefineHandlers","typesAndFields","fields","core","declare","keep","refer","builder","node","scope","memberExpressionObjectHandler","context","declaration","addReference","graph","addEdge","ScopeManager","globalExportsIdentifier","globalModuleIdentifier","memberExpressionPropertyHandler","parent","isMemberExpression","computed"],"mappings":"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","sourcesContent":["import { types as t } from '@babel/core';\nimport type { Aliases, Identifier, Node, VisitorKeys } from '@babel/types';\nimport { peek } from '@linaria/babel-preset';\nimport GraphBuilderState from './GraphBuilderState';\nimport type { IdentifierHandlerType, NodeType } from './types';\nimport { identifierHandlers as core } from './langs/core';\nimport ScopeManager from './scope';\n\ntype HandlerFn = <TParent extends Node = Node>(\n  builder: GraphBuilderState,\n  node: Identifier,\n  parent: TParent,\n  parentKey: VisitorKeys[TParent['type']],\n  listIdx: number | null\n) => void;\n\ntype Handler = IdentifierHandlerType | HandlerFn;\n\nconst handlers: {\n  [key: string]: Handler;\n} = {};\n\nfunction isAlias(type: NodeType): type is keyof Aliases {\n  return type in t.FLIPPED_ALIAS_KEYS;\n}\n\nexport function defineHandler(\n  typeOrAlias: NodeType,\n  field: string,\n  handler: Handler\n) {\n  const types = isAlias(typeOrAlias)\n    ? t.FLIPPED_ALIAS_KEYS[typeOrAlias]\n    : [typeOrAlias];\n  types.forEach((type: string) => {\n    handlers[`${type}:${field}`] = handler;\n  });\n}\n\nexport function batchDefineHandlers(\n  typesAndFields: [NodeType, ...string[]][],\n  handler: IdentifierHandlerType\n) {\n  typesAndFields.forEach(([type, ...fields]) =>\n    fields.forEach((field) => defineHandler(type, field, handler))\n  );\n}\n\nbatchDefineHandlers([...core.declare], 'declare');\n\nbatchDefineHandlers([...core.keep], 'keep');\n\nbatchDefineHandlers([...core.refer], 'refer');\n\n/*\n * Special case for FunctionDeclaration\n * Function id should be defined in the parent scope\n */\ndefineHandler(\n  'FunctionDeclaration',\n  'id',\n  (builder: GraphBuilderState, node: Identifier) => {\n    builder.scope.declare(node, false, null, 1);\n  }\n);\n\n/*\n * Special handler for [obj.member = 42] = [1] in different contexts\n */\nconst memberExpressionObjectHandler = (\n  builder: GraphBuilderState,\n  node: Identifier\n) => {\n  const context = peek(builder.context);\n  const declaration = builder.scope.addReference(node);\n  if (declaration) {\n    builder.graph.addEdge(node, declaration);\n\n    if (context === 'lval') {\n      // One exception here: we shake exports,\n      // so `exports` does not depend on its members' assignments.\n      if (\n        declaration !== ScopeManager.globalExportsIdentifier &&\n        declaration !== ScopeManager.globalModuleIdentifier\n      ) {\n        builder.graph.addEdge(declaration, node);\n      }\n    }\n  }\n};\n\ndefineHandler('MemberExpression', 'object', memberExpressionObjectHandler);\ndefineHandler(\n  'OptionalMemberExpression',\n  'object',\n  memberExpressionObjectHandler\n);\n\n/*\n * Special handler for obj.member and obj[member]\n */\nconst memberExpressionPropertyHandler = (\n  builder: GraphBuilderState,\n  node: Identifier,\n  parent: Node\n) => {\n  if (t.isMemberExpression(parent) && parent.computed) {\n    const declaration = builder.scope.addReference(node);\n    // Let's check that it's not a global variable\n    if (declaration) {\n      // usage of a variable depends on its declaration\n      builder.graph.addEdge(node, declaration);\n\n      const context = peek(builder.context);\n      if (context === 'lval') {\n        // This is an identifier in the left side of an assignment expression and a variable value depends on that.\n        builder.graph.addEdge(declaration, node);\n      }\n    }\n  }\n};\n\ndefineHandler('MemberExpression', 'property', memberExpressionPropertyHandler);\ndefineHandler(\n  'OptionalMemberExpression',\n  'property',\n  memberExpressionPropertyHandler\n);\n\nexport default handlers;\n"],"file":"identifierHandlers.js"}