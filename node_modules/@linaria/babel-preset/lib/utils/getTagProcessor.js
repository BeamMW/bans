"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getTagProcessor;

var _fs = require("fs");

var _path = require("path");

var _core = require("@babel/core");

var _findUp = _interopRequireDefault(require("find-up"));

var _BaseProcessor = _interopRequireDefault(require("@linaria/core/processors/BaseProcessor"));

var _logger = require("@linaria/logger");

var _collectExportsAndImports = _interopRequireDefault(require("./collectExportsAndImports"));

var _getSource = _interopRequireDefault(require("./getSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const last = arr => arr[arr.length - 1];

function buildCodeFrameError(path, message) {
  try {
    return path.buildCodeFrameError(message);
  } catch {
    return new Error(message);
  }
}

const definedTagsCache = new Map();

const getDefinedTagsFromPackage = (pkgName, filename) => {
  var _packageJSON$linaria;

  if (definedTagsCache.has(pkgName)) {
    return definedTagsCache.get(pkgName);
  }

  const pkgPath = require.resolve(pkgName, {
    paths: [(0, _path.dirname)(filename)]
  });

  const packageJSONPath = _findUp.default.sync('package.json', {
    cwd: pkgPath
  });

  if (!packageJSONPath) {
    return undefined;
  }

  const packageDir = (0, _path.dirname)(packageJSONPath);
  const packageJSON = JSON.parse((0, _fs.readFileSync)(packageJSONPath, 'utf8'));
  const definedTags = (_packageJSON$linaria = packageJSON.linaria) === null || _packageJSON$linaria === void 0 ? void 0 : _packageJSON$linaria.tags;
  const normalizedTags = definedTags ? Object.entries(definedTags).reduce((acc, [key, value]) => ({ ...acc,
    [key]: value.startsWith('.') ? (0, _path.join)(packageDir, value) : require.resolve(value, {
      paths: [packageDir]
    })
  }), {}) : undefined;
  definedTagsCache.set(pkgName, normalizedTags);
  return normalizedTags;
};

function isValidProcessorClass(module) {
  return module instanceof _BaseProcessor.default.constructor;
}

function getProcessor(packageName, tagName, filename) {
  const definedTags = getDefinedTagsFromPackage(packageName, filename);
  const processorPath = definedTags === null || definedTags === void 0 ? void 0 : definedTags[tagName];

  if (!processorPath) {
    return null;
  }

  const Processor = require(processorPath).default;

  if (!isValidProcessorClass(Processor)) {
    return null;
  }

  return Processor;
}

function getBuilderForTemplate(path, imports, filename) {
  let tagPath;

  const isDescendant = (a, b) => {
    if (a.isDescendant(b)) {
      tagPath = a;
      return true;
    }

    return false;
  };

  const relatedImport = imports.find(i => {
    const {
      local
    } = i;

    if (!local.isIdentifier()) {
      return isDescendant(local, path);
    }

    const binding = local.scope.getBinding(local.node.name);
    return binding === null || binding === void 0 ? void 0 : binding.referencePaths.some(p => isDescendant(p, path));
  });

  if (!tagPath || !relatedImport || !tagPath.isExpression()) {
    return null;
  }

  const Processor = getProcessor(relatedImport.source, relatedImport.imported, filename);

  if (!Processor) {
    return null;
  }

  const params = [];
  let prev = tagPath;
  let current = tagPath.parentPath;

  while (current && current !== path) {
    var _current, _current2, _current3;

    if ((_current = current) !== null && _current !== void 0 && _current.isSequenceExpression() && last(current.node.expressions) === prev.node) {
      prev = current;
      current = current.parentPath; // eslint-disable-next-line no-continue

      continue;
    }

    if ((_current2 = current) !== null && _current2 !== void 0 && _current2.isCallExpression() && current.node.callee === prev.node) {
      const args = current.get('arguments');
      params.push(['call', ...args.map(arg => [(0, _getSource.default)(arg), arg])]);
      prev = current;
      current = current.parentPath; // eslint-disable-next-line no-continue

      continue;
    }

    if ((_current3 = current) !== null && _current3 !== void 0 && _current3.isMemberExpression() && current.node.object === prev.node) {
      const property = current.get('property');

      if (property.isPrivateName()) {
        // eslint-disable-next-line no-continue
        continue;
      }

      params.push(['member', property]);
      prev = current;
      current = current.parentPath; // eslint-disable-next-line no-continue

      continue;
    }

    throw buildCodeFrameError(path, 'Unexpected tag usage');
  }

  return (...args) => new Processor(_core.types, params, tagPath.node, ...args);
}

function getDisplayName(path, idx, state) {
  let displayName;
  const parent = path.findParent(p => p.isObjectProperty() || p.isJSXOpeningElement() || p.isVariableDeclarator());

  if (parent) {
    if (parent.isObjectProperty()) {
      if ('name' in parent.node.key) {
        displayName = parent.node.key.name;
      } else if ('value' in parent.node.key) {
        displayName = parent.node.key.value.toString();
      } else {
        const keyPath = parent.get('key');
        displayName = (0, _getSource.default)(keyPath);
      }
    } else if (parent.isJSXOpeningElement()) {
      const name = parent.get('name');

      if (name.isJSXIdentifier()) {
        displayName = name.node.name;
      }
    } else if (parent.isVariableDeclarator()) {
      const id = parent.get('id');

      if (id.isIdentifier()) {
        displayName = id.node.name;
      }
    }
  }

  if (!displayName) {
    // Try to derive the path from the filename
    displayName = (0, _path.basename)(state.file.opts.filename);

    if (/^index\.[a-z\d]+$/.test(displayName)) {
      // If the file name is 'index', better to get name from parent folder
      displayName = (0, _path.basename)((0, _path.dirname)(state.file.opts.filename));
    } // Remove the file extension


    displayName = displayName.replace(/\.[a-z\d]+$/, '');

    if (displayName) {
      displayName += idx;
    } else {
      throw new Error("Couldn't determine a name for the component. Ensure that it's either:\n" + '- Assigned to a variable\n' + '- Is an object property\n' + '- Is a prop in a JSX element\n');
    }
  }

  return displayName;
}

const counters = new WeakMap();

const getNextIndex = state => {
  var _counters$get;

  const counter = (_counters$get = counters.get(state)) !== null && _counters$get !== void 0 ? _counters$get : 0;
  counters.set(state, counter + 1);
  return counter;
};

const cache = new WeakMap();

function getTagProcessor(path, state, options) {
  var _cache$get;

  if (!cache.has(path)) {
    // Increment the index of the style we're processing
    // This is used for slug generation to prevent collision
    // Also used for display name if it couldn't be determined
    const idx = getNextIndex(state);
    const root = path.findParent(p => p.isProgram() || p.isFile());

    if (!root) {
      // How is this possible?
      (0, _logger.warn)('get-tag-context', 'Could not find root node for template tag');
      return null;
    }

    const {
      imports
    } = (0, _collectExportsAndImports.default)(root, state.file.opts.filename);

    try {
      const builder = getBuilderForTemplate(path, imports, state.file.opts.filename);

      if (builder) {
        const displayName = getDisplayName(path, idx, state);
        const processor = builder(displayName, idx, options, state.file.opts);
        cache.set(path, processor);
      } else {
        cache.set(path, null);
      }
    } catch (e) {
      if (e instanceof Error) {
        throw buildCodeFrameError(path, e.message);
      }

      throw e;
    }
  }

  return (_cache$get = cache.get(path)) !== null && _cache$get !== void 0 ? _cache$get : null;
}
//# sourceMappingURL=getTagProcessor.js.map