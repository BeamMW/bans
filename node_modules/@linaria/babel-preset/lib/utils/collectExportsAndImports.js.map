{"version":3,"file":"collectExportsAndImports.js","names":["safeResolve","name","filename","require","resolve","paths","dirname","e","getValue","node","type","value","isExportKindIsValue","p","exportKind","isImportKindIsValue","importKind","collectors","ImportSpecifier","path","imported","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","collectFromImportDeclaration","state","source","forEach","specifier","isImportSpecifier","collector","imports","push","map","item","whatIsDestructed","destructedProps","properties","property","isObjectProperty","key","isIdentifier","isStringLiteral","what","as","isRestElement","arg","warn","fromVariableDeclarator","isSync","id","isObjectPattern","collectFromDynamicImport","parentPath","callExpression","isCallExpression","sourcePath","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getImportTypeByInteropFunction","callee","undefined","startsWith","collectFromRequire","isRequire","variableDeclarator","isMemberExpression","unfoldNamespaceImports","result","importItem","binding","scope","getBinding","referenced","referencePath","referencePaths","isExportSpecifier","collectFromExportSpecifier","exported","exports","collectFromExportNamedDeclaration","specifiers","declaration","isVariableDeclaration","declarator","cache","WeakMap","collectExportsAndImports","has","traverse","ExportNamedDeclaration","ImportDeclaration","Import","Identifier","set"],"sources":["../../src/utils/collectExportsAndImports.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax,no-continue */\nimport { dirname } from 'path';\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  ExportNamedDeclaration,\n  ExportSpecifier,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectPattern,\n  StringLiteral,\n  VariableDeclarator,\n  ExportDefaultSpecifier,\n  ExportNamespaceSpecifier,\n} from '@babel/types';\n\nimport { warn } from '@linaria/logger';\n\nimport isRequire from './isRequire';\n\ninterface IImportSpecifier {\n  imported: string | '=' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n}\n\nexport interface IImport extends IImportSpecifier {\n  source: string;\n}\n\nexport interface IExport {\n  exported: string;\n  local: NodePath;\n}\n\nexport interface IState {\n  imports: IImport[];\n  exports: IExport[];\n  filename: string;\n}\n\nconst safeResolve = (name: string, filename: string): string => {\n  try {\n    return require.resolve(name, {\n      paths: [dirname(filename)],\n    });\n  } catch (e: unknown) {\n    return name;\n  }\n};\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We only need value imports. Type imports can be ignored.\nconst isExportKindIsValue = <\n  T extends { node: { exportKind?: 'value' | unknown } }\n>(\n  p: T\n): p is T & { node: { exportKind: 'value' } } =>\n  !p.node.exportKind || p.node.exportKind === 'value';\n\n// We only need value exports. Type exports can be ignored.\nconst isImportKindIsValue = <\n  T extends { node: { importKind?: 'value' | unknown } }\n>(\n  p: T\n): p is T & { node: { importKind: 'value' } } =>\n  !p.node.importKind || p.node.importKind === 'value';\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>\n  ) => IImportSpecifier[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>): IImportSpecifier[] {\n    if (!isImportKindIsValue(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>\n  ): IImportSpecifier[] {\n    const local = path.get('local');\n    return [{ imported: '=', local }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>\n  ): IImportSpecifier[] {\n    const local = path.get('local');\n    return [{ imported: '*', local }];\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: IState\n): void {\n  // If importKind is specified, and it's not a value, ignore that import\n  if (!isImportKindIsValue(path)) return;\n\n  const source = safeResolve(getValue(path.get('source')), state.filename);\n  path\n    .get('specifiers')\n    .forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n      if (specifier.isImportSpecifier() && !isImportKindIsValue(specifier))\n        return;\n\n      const collector = collectors[\n        specifier.node.type\n      ] as typeof collectors[T['type']];\n\n      state.imports.push(\n        ...collector(specifier).map((item) => ({ ...item, source }))\n      );\n    });\n}\n\ninterface IDestructed {\n  what: string | '*';\n  as: NodePath<Identifier | MemberExpression>;\n}\n\nfunction whatIsDestructed(path: NodePath<ObjectPattern>): IDestructed[] {\n  const destructedProps: IDestructed[] = [];\n  const properties = path.get('properties');\n  properties.forEach((property) => {\n    if (property.isObjectProperty()) {\n      const key = property.get('key');\n      if (!key.isIdentifier() && !key.isStringLiteral()) return;\n      const what = getValue(key);\n\n      const as = property.get('value');\n      if (!as.isIdentifier()) return;\n\n      destructedProps.push({ what, as });\n\n      return;\n    }\n\n    // If it is not an ObjectProperty, it is a RestElement\n    // In such case it is the same as importing the whole namespace\n    if (property.isRestElement()) {\n      const arg = property.get('argument');\n      if (!arg.isIdentifier()) {\n        // some unexpected type of argument\n        return;\n      }\n\n      destructedProps.push({\n        as: arg,\n        what: '*',\n      });\n\n      return;\n    }\n\n    warn(\n      'evaluator:collectExportsAndImports',\n      'Unknown type of property:',\n      property.node.type\n    );\n  });\n\n  return destructedProps;\n}\n\nfunction fromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    warn('evaluator:collectExportsAndImports', '`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction collectFromDynamicImport(path: NodePath<Import>, state: IState): void {\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = safeResolve(sourcePath.node.value, state.filename);\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    fromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction getImportTypeByInteropFunction(\n  path: NodePath<CallExpression>\n): '*' | '=' | undefined {\n  const callee = path.get('callee');\n  if (!callee.isIdentifier()) {\n    return undefined;\n  }\n\n  const { name } = callee.node;\n  if (name.startsWith('_interopRequireDefault')) {\n    return '=';\n  }\n\n  if (name.startsWith('_interopRequireWildcard')) {\n    return '*';\n  }\n\n  if (name.startsWith('__rest')) {\n    return '*';\n  }\n\n  return undefined;\n}\n\nfunction collectFromRequire(path: NodePath<Identifier>, state: IState): void {\n  if (!isRequire(path)) return;\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = safeResolve(sourcePath.node.value, state.filename);\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression() && key === 0) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportTypeByInteropFunction(container);\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unknown wrapper of require',\n        container.node.callee\n      );\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unexpected require inside',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Id should be Identifier',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    state.imports.push({\n      imported,\n      local: id,\n      source,\n    });\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Property should be Identifier or StringLiteral',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n        });\n      } else {\n        warn(\n          'evaluator:collectExportsAndImports',\n          'Id should be Identifier',\n          variableDeclarator.node.type\n        );\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    fromVariableDeclarator(container, true).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction unfoldNamespaceImports(imports: IImport[]): IImport[] {\n  const result: IImport[] = [];\n  for (const importItem of imports) {\n    if (importItem.imported === '*') {\n      const { local } = importItem;\n      if (!local.isIdentifier()) {\n        // TODO: handle it\n        result.push(importItem);\n        continue;\n      }\n\n      const binding = local.scope.getBinding(local.node.name);\n      if (!binding?.referenced) {\n        // Imported namespace is not referenced and probably not used,\n        // but it can have side effects, so we should keep it as is\n        result.push(importItem);\n        continue;\n      }\n\n      for (const referencePath of binding?.referencePaths ?? []) {\n        const { parentPath } = referencePath;\n        if (\n          parentPath?.isMemberExpression() &&\n          referencePath.key === 'object'\n        ) {\n          const property = parentPath.get('property');\n          if (property.isIdentifier()) {\n            const { name } = property.node;\n            result.push({\n              ...importItem,\n              imported: name === 'default' ? '=' : name,\n              local: parentPath, // TODO: try to resolve identifier\n            });\n\n            continue;\n          }\n\n          // Otherwise, we can't predict usage and import it as is\n          result.push(importItem);\n          break;\n        }\n\n        if (\n          parentPath?.isVariableDeclarator() &&\n          referencePath.key === 'init'\n        ) {\n          fromVariableDeclarator(parentPath, true).map((prop) =>\n            result.push({ ...importItem, imported: prop.what, local: prop.as })\n          );\n\n          continue;\n        }\n\n        if (parentPath?.isExportSpecifier()) {\n          // The whole namespace is re-exported\n          result.push(importItem);\n          break;\n        }\n\n        // Otherwise, we can't predict usage and import it as is\n        // TODO: handle more cases\n        warn(\n          'evaluator:unfoldNamespaceImports',\n          'Unknown reference',\n          referencePath.node.type\n        );\n        result.push(importItem);\n        break;\n      }\n    } else {\n      result.push(importItem);\n    }\n  }\n\n  return result;\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  state: IState\n): void {\n  if (path.isExportSpecifier()) {\n    const local = path.get('local');\n    const exported = getValue(path.get('exported'));\n    state.exports.push({ local, exported });\n    return;\n  }\n\n  // TODO: handle other cases\n  warn(\n    'evaluator:collectExportsAndImports',\n    'Unprocessed ExportSpecifier',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: IState\n): void {\n  if (!isExportKindIsValue(path)) return;\n\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      fromVariableDeclarator(declarator, true).forEach((prop) => {\n        // What is defined\n        state.exports.push({ exported: prop.what, local: prop.as });\n      });\n    });\n  }\n}\n\nconst cache = new WeakMap<NodePath, IState>();\n\nexport default function collectExportsAndImports(\n  path: NodePath,\n  filename: string\n): IState {\n  const state: IState = {\n    imports: [],\n    exports: [],\n    filename,\n  };\n\n  if (cache.has(path)) {\n    return cache.get(path) ?? state;\n  }\n\n  path.traverse(\n    {\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequire,\n    },\n    state\n  );\n\n  state.imports = unfoldNamespaceImports(state.imports);\n\n  cache.set(path, state);\n\n  return state;\n}\n"],"mappings":"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"}