"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = collectTemplateDependencies;

var _generator = _interopRequireDefault(require("@babel/generator"));

var _logger = require("@linaria/logger");

var _types = require("../types");

var _getSource = _interopRequireDefault(require("./getSource"));

var _getTagProcessor = _interopRequireDefault(require("./getTagProcessor"));

var _throwIfInvalid = _interopRequireDefault(require("./throwIfInvalid"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.
 * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.
 */

/**
 * Hoist the node and its dependencies to the highest scope possible
 */
function hoist(babel, ex) {
  const Identifier = idPath => {
    if (!idPath.isReferencedIdentifier()) {
      return;
    }

    const binding = idPath.scope.getBinding(idPath.node.name);
    if (!binding) return;
    const {
      scope,
      path: bindingPath,
      referencePaths
    } = binding; // parent here can be null or undefined in different versions of babel

    if (!scope.parent) {
      // It's a variable from global scope
      return;
    }

    if (bindingPath.isVariableDeclarator()) {
      const initPath = bindingPath.get('init');
      hoist(babel, initPath);
      initPath.hoist(scope);

      if (initPath.isIdentifier()) {
        referencePaths.forEach(referencePath => {
          referencePath.replaceWith(babel.types.identifier(initPath.node.name));
        });
      }
    }
  };

  if (ex.isIdentifier()) {
    Identifier(ex);
    return;
  }

  ex.traverse({
    Identifier
  });
}

function collectTemplateDependencies(babel, path, state, options) {
  const {
    types: t
  } = babel;
  const quasi = path.get('quasi');
  const quasis = quasi.get('quasis');
  const expressions = quasi.get('expressions');
  (0, _logger.debug)('template-parse:identify-expressions', expressions.length);
  const expressionValues = expressions.map(ex => {
    if (!ex.isExpression()) {
      throw ex.buildCodeFrameError(`The expression '${(0, _generator.default)(ex.node).code}' is not supported.`);
    }

    const result = ex.evaluate();
    let value;

    if (result.confident) {
      value = result.value;
    } else {
      // @ts-expect-error result has deopt field, but it's not in types
      const {
        deopt
      } = result; // At least in some cases deopt contains an expression hidden behind an identifier
      // If it is a TaggedTemplateExpression, we can get class name for it

      if (deopt && deopt.isTaggedTemplateExpression()) {
        const context = (0, _getTagProcessor.default)(deopt, state, options);

        if (context !== null && context !== void 0 && context.asSelector) {
          return {
            kind: _types.ValueType.VALUE,
            value: context.asSelector,
            ex,
            source: (0, _getSource.default)(ex)
          };
        }
      }
    }

    if (value !== undefined) {
      (0, _throwIfInvalid.default)(value, ex);
      return {
        kind: _types.ValueType.VALUE,
        value,
        ex,
        source: (0, _getSource.default)(ex)
      };
    }

    if (options.evaluate && !(ex.isFunctionExpression() || ex.isArrowFunctionExpression())) {
      // save original expression that may be changed during hoisting
      const originalExNode = t.cloneNode(ex.node);
      hoist(babel, ex); // save hoisted expression to be used to evaluation

      const hoistedExNode = t.cloneNode(ex.node); // get back original expression to the tree

      ex.replaceWith(originalExNode);
      return {
        kind: _types.ValueType.LAZY,
        ex: hoistedExNode,
        originalEx: ex,
        source: (0, _getSource.default)(ex)
      };
    }

    return {
      kind: _types.ValueType.FUNCTION,
      ex,
      source: (0, _getSource.default)(ex)
    };
  });
  (0, _logger.debug)('template-parse:evaluate-expressions', expressionValues.map(expressionValue => expressionValue.kind === _types.ValueType.VALUE ? expressionValue.value : 'lazy'));
  return [quasis, expressionValues];
}
//# sourceMappingURL=collectTemplateDependencies.js.map