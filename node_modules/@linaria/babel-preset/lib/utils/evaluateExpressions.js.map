{"version":3,"file":"evaluateExpressions.js","names":["isLazyValue","v","kind","ValueType","LAZY","isEvaluatedValue","VALUE","expressionWrapperTpl","statement","expressionTpl","expression","exportsLinariaPrevalTpl","addLinariaPreval","types","t","path","lazyDeps","wrapName","scope","generateUidIdentifier","statements","expressions","arrayExpression","map","exp","programNode","node","program","body","directives","sourceType","interpreter","getExpression","value","originalEx","ex","hasPreval","exports","evaluateExpressions","babel","templateExpressions","options","filename","dependencies","evaluatedDeps","forEach","deps","push","filter","dep","undefined","source","expressionsToEvaluate","unwrapNode","originalLazyExpressions","debug","length","lazyValues","generator","code","programWithPreval","evaluation","evaluate","__linariaPreval","e","error","Error","stack","valueCache","Map","key","idx","throwIfInvalid","set"],"sources":["../../src/utils/evaluateExpressions.ts"],"sourcesContent":["import generator from '@babel/generator';\nimport { expression, statement } from '@babel/template';\nimport type { NodePath } from '@babel/traverse';\nimport type { Program, Expression } from '@babel/types';\n\nimport { debug, error } from '@linaria/logger';\n\nimport type { Core } from '../babel';\nimport evaluate from '../evaluators';\nimport type {\n  LazyValue,\n  State,\n  StrictOptions,\n  TemplateExpression,\n  Value,\n  ValueCache,\n  ExpressionValue,\n  EvaluatedValue,\n} from '../types';\nimport { ValueType } from '../types';\n\nimport throwIfInvalid from './throwIfInvalid';\nimport unwrapNode from './unwrapNode';\n\nfunction isLazyValue(v: ExpressionValue): v is LazyValue {\n  return v.kind === ValueType.LAZY;\n}\n\nfunction isEvaluatedValue(v: ExpressionValue): v is EvaluatedValue {\n  return v.kind === ValueType.VALUE;\n}\n\n// All exported values will be wrapped with this function\nconst expressionWrapperTpl = statement(`\n  const %%wrapName%% = (fn) => {\n    try {\n      return fn();\n    } catch (e) {\n      return e;\n    }\n  };\n`);\n\nconst expressionTpl = expression('%%wrapName%%(() => %%expression%%)');\nconst exportsLinariaPrevalTpl = statement(\n  'exports.__linariaPreval = %%expressions%%'\n);\n\nfunction addLinariaPreval(\n  { types: t }: Core,\n  path: NodePath<Program>,\n  lazyDeps: Array<Expression>\n): Program {\n  // Constant __linariaPreval with all dependencies\n  const wrapName = path.scope.generateUidIdentifier('wrap');\n  const statements = [\n    expressionWrapperTpl({ wrapName }),\n    exportsLinariaPrevalTpl({\n      expressions: t.arrayExpression(\n        lazyDeps.map((exp) => expressionTpl({ expression: exp, wrapName }))\n      ),\n    }),\n  ];\n\n  const programNode = path.node;\n  return t.program(\n    [...programNode.body, ...statements],\n    programNode.directives,\n    programNode.sourceType,\n    programNode.interpreter\n  );\n}\n\nconst getExpression = (\n  value:\n    | {\n        originalEx: NodePath<Expression>;\n        ex: NodePath<Expression> | Expression;\n      }\n    | {\n        ex: NodePath<Expression>;\n      }\n): NodePath<Expression> =>\n  'originalEx' in value ? value.originalEx : value.ex;\n\nfunction hasPreval(\n  exports: unknown\n): exports is { __linariaPreval: Value[] | null | undefined } {\n  if (!exports || typeof exports !== 'object') {\n    return false;\n  }\n\n  return '__linariaPreval' in exports;\n}\n\nexport default function evaluateExpressions(\n  babel: Core,\n  program: NodePath<Program>,\n  templateExpressions: TemplateExpression[],\n  options: StrictOptions,\n  filename: string\n): [dependencies: State['dependencies'], valueCache: ValueCache] {\n  const dependencies: State['dependencies'] = [];\n\n  const lazyDeps: Omit<LazyValue, 'kind'>[] = [];\n  const evaluatedDeps: Omit<EvaluatedValue, 'kind'>[] = [];\n\n  templateExpressions.forEach(({ expressions, dependencies: deps }) => {\n    lazyDeps.push(...expressions.filter(isLazyValue));\n    evaluatedDeps.push(...expressions.filter(isEvaluatedValue));\n\n    deps.forEach((dep) => {\n      if (dep.value !== undefined) {\n        evaluatedDeps.push({\n          ex: dep.ex,\n          source: dep.source,\n          value: dep.value,\n        });\n      } else {\n        lazyDeps.push({\n          ex: dep.ex,\n          originalEx: dep.ex,\n          source: dep.source,\n        });\n      }\n    });\n  });\n\n  const expressionsToEvaluate = lazyDeps.map((v) => unwrapNode(v.ex));\n  const originalLazyExpressions = lazyDeps.map((v) =>\n    unwrapNode(getExpression(v))\n  );\n\n  debug('lazy-deps:count', lazyDeps.length);\n\n  let lazyValues: Value[] = [];\n\n  if (expressionsToEvaluate.length > 0) {\n    debug(\n      'lazy-deps:original-expressions-list',\n      originalLazyExpressions.map((node) => generator(node).code)\n    );\n    debug(\n      'lazy-deps:expressions-to-eval-list',\n      expressionsToEvaluate.map((node) => generator(node).code)\n    );\n\n    const programWithPreval = addLinariaPreval(\n      babel,\n      program,\n      expressionsToEvaluate\n    );\n    const { code } = generator(programWithPreval);\n    debug('lazy-deps:evaluate', '');\n    try {\n      const evaluation = evaluate(code, filename, options);\n      debug('lazy-deps:sub-files', evaluation.dependencies);\n\n      dependencies.push(...evaluation.dependencies);\n      lazyValues = hasPreval(evaluation.value)\n        ? evaluation.value.__linariaPreval || []\n        : [];\n      debug('lazy-deps:values', lazyValues);\n    } catch (e: unknown) {\n      error('lazy-deps:evaluate:error', code);\n      if (e instanceof Error) {\n        throw new Error(\n          `An unexpected runtime error occurred during dependencies evaluation: \\n${e.stack}\\n\\nIt may happen when your code or third party module is invalid or uses identifiers not available in Node environment, eg. window. \\n` +\n            'Note that line numbers in above stack trace will most likely not match, because Linaria needed to transform your code a bit.\\n'\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  const valueCache: ValueCache = new Map();\n\n  originalLazyExpressions.forEach((key, idx) => {\n    throwIfInvalid(lazyValues[idx], getExpression(lazyDeps[idx]));\n    return valueCache.set(key, lazyValues[idx]);\n  });\n\n  evaluatedDeps.forEach((dep) => {\n    throwIfInvalid(dep.value, dep.ex);\n    return valueCache.set(dep.ex.node, dep.value);\n  });\n\n  return [dependencies, valueCache];\n}\n"],"mappings":"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"}