"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = evaluateExpressions;

var _generator = _interopRequireDefault(require("@babel/generator"));

var _template = require("@babel/template");

var _logger = require("@linaria/logger");

var _evaluators = _interopRequireDefault(require("../evaluators"));

var _types = require("../types");

var _throwIfInvalid = _interopRequireDefault(require("./throwIfInvalid"));

var _unwrapNode = _interopRequireDefault(require("./unwrapNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isLazyValue(v) {
  return v.kind === _types.ValueType.LAZY;
}

function isEvaluatedValue(v) {
  return v.kind === _types.ValueType.VALUE;
} // All exported values will be wrapped with this function


const expressionWrapperTpl = (0, _template.statement)(`
  const %%wrapName%% = (fn) => {
    try {
      return fn();
    } catch (e) {
      return e;
    }
  };
`);
const expressionTpl = (0, _template.expression)('%%wrapName%%(() => %%expression%%)');
const exportsLinariaPrevalTpl = (0, _template.statement)('exports.__linariaPreval = %%expressions%%');

function addLinariaPreval({
  types: t
}, path, lazyDeps) {
  // Constant __linariaPreval with all dependencies
  const wrapName = path.scope.generateUidIdentifier('wrap');
  const statements = [expressionWrapperTpl({
    wrapName
  }), exportsLinariaPrevalTpl({
    expressions: t.arrayExpression(lazyDeps.map(exp => expressionTpl({
      expression: exp,
      wrapName
    })))
  })];
  const programNode = path.node;
  return t.program([...programNode.body, ...statements], programNode.directives, programNode.sourceType, programNode.interpreter);
}

const getExpression = value => 'originalEx' in value ? value.originalEx : value.ex;

function hasPreval(exports) {
  if (!exports || typeof exports !== 'object') {
    return false;
  }

  return '__linariaPreval' in exports;
}

function evaluateExpressions(babel, program, templateExpressions, options, filename) {
  const dependencies = [];
  const lazyDeps = [];
  const evaluatedDeps = [];
  templateExpressions.forEach(({
    expressions,
    dependencies: deps
  }) => {
    lazyDeps.push(...expressions.filter(isLazyValue));
    evaluatedDeps.push(...expressions.filter(isEvaluatedValue));
    deps.forEach(dep => {
      if (dep.value !== undefined) {
        evaluatedDeps.push({
          ex: dep.ex,
          source: dep.source,
          value: dep.value
        });
      } else {
        lazyDeps.push({
          ex: dep.ex,
          originalEx: dep.ex,
          source: dep.source
        });
      }
    });
  });
  const expressionsToEvaluate = lazyDeps.map(v => (0, _unwrapNode.default)(v.ex));
  const originalLazyExpressions = lazyDeps.map(v => (0, _unwrapNode.default)(getExpression(v)));
  (0, _logger.debug)('lazy-deps:count', lazyDeps.length);
  let lazyValues = [];

  if (expressionsToEvaluate.length > 0) {
    (0, _logger.debug)('lazy-deps:original-expressions-list', originalLazyExpressions.map(node => (0, _generator.default)(node).code));
    (0, _logger.debug)('lazy-deps:expressions-to-eval-list', expressionsToEvaluate.map(node => (0, _generator.default)(node).code));
    const programWithPreval = addLinariaPreval(babel, program, expressionsToEvaluate);
    const {
      code
    } = (0, _generator.default)(programWithPreval);
    (0, _logger.debug)('lazy-deps:evaluate', '');

    try {
      const evaluation = (0, _evaluators.default)(code, filename, options);
      (0, _logger.debug)('lazy-deps:sub-files', evaluation.dependencies);
      dependencies.push(...evaluation.dependencies);
      lazyValues = hasPreval(evaluation.value) ? evaluation.value.__linariaPreval || [] : [];
      (0, _logger.debug)('lazy-deps:values', lazyValues);
    } catch (e) {
      (0, _logger.error)('lazy-deps:evaluate:error', code);

      if (e instanceof Error) {
        throw new Error(`An unexpected runtime error occurred during dependencies evaluation: \n${e.stack}\n\nIt may happen when your code or third party module is invalid or uses identifiers not available in Node environment, eg. window. \n` + 'Note that line numbers in above stack trace will most likely not match, because Linaria needed to transform your code a bit.\n');
      } else {
        throw e;
      }
    }
  }

  const valueCache = new Map();
  originalLazyExpressions.forEach((key, idx) => {
    (0, _throwIfInvalid.default)(lazyValues[idx], getExpression(lazyDeps[idx]));
    return valueCache.set(key, lazyValues[idx]);
  });
  evaluatedDeps.forEach(dep => {
    (0, _throwIfInvalid.default)(dep.value, dep.ex);
    return valueCache.set(dep.ex.node, dep.value);
  });
  return [dependencies, valueCache];
}
//# sourceMappingURL=evaluateExpressions.js.map