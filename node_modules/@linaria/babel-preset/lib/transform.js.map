{"version":3,"sources":["../src/transform.ts"],"names":["STYLIS_DECLARATION","posixSep","path","posix","sep","babelPreset","require","resolve","transformUrl","url","outputFilename","sourceFilename","platformPath","relative","dirname","split","join","shouldTransformCode","code","test","extractCssFromAst","babelFileResult","options","metadata","transformedCode","map","linaria","sourceMap","rules","replacements","dependencies","mappings","cssText","preprocessor","selector","text","stylis","use","context","decl","replace","match","p1","p2","p3","p4","filename","Object","keys","forEach","index","push","generated","line","column","original","start","name","source","atom","cssSourceMapText","length","generator","SourceMapGenerator","file","mapping","addMapping","assign","setSourceContent","toString","transform","inputSourceMap","pluginOptions","babelOptions","ast","caller","rootMode","presets","babelrc","configFile","sourceMaps","sourceFileName"],"mappings":";;;;;;;;;;AASA;;AAEA;;AACA;;AAEA;;AACA;;AACA;;;;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA,MAAMA,kBAAkB,GAAG,CAA3B;AACA,MAAMC,QAAQ,GAAGC,cAAKC,KAAL,CAAWC,GAA5B;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAACC,OAAR,CAAgB,SAAhB,CAApB;;AAEO,SAASC,YAAT,CACLC,GADK,EAELC,cAFK,EAGLC,cAHK,EAILC,YAAyB,GAAGV,aAJvB,EAKL;AACA;AACA,QAAMW,QAAQ,GAAGD,YAAY,CAACC,QAAb,CACfD,YAAY,CAACE,OAAb,CAAqBJ,cAArB,CADe,EAEf;AACAE,EAAAA,YAAY,CAACL,OAAb,CAAqBK,YAAY,CAACE,OAAb,CAAqBH,cAArB,CAArB,EAA2DF,GAA3D,CAHe,CAAjB;;AAMA,MAAIG,YAAY,CAACR,GAAb,KAAqBH,QAAzB,EAAmC;AACjC,WAAOY,QAAP;AACD;;AAED,SAAOA,QAAQ,CAACE,KAAT,CAAeH,YAAY,CAACR,GAA5B,EAAiCY,IAAjC,CAAsCf,QAAtC,CAAP;AACD;;AAEM,SAASgB,mBAAT,CAA6BC,IAA7B,EAAoD;AACzD,SAAO,iBAAiBC,IAAjB,CAAsBD,IAAtB,CAAP;AACD;;AAEM,SAASE,iBAAT,CACLC,eADK,EAELH,IAFK,EAGLI,OAHK,EAIG;AACR,QAAM;AAAEC,IAAAA,QAAF;AAAYL,IAAAA,IAAI,EAAEM,eAAlB;AAAmCC,IAAAA;AAAnC,MAA2CJ,eAAjD;;AAEA,MACE,CAACE,QAAD,IACA,CAAEA,QAAD,CAA+DG,OAFlE,EAGE;AACA,WAAO;AACLR,MAAAA,IAAI,EAAEM,eAAe,IAAI,EADpB;AACwB;AAC7BG,MAAAA,SAAS,EAAEF;AAFN,KAAP;AAID;;AAED,QAAM;AAAEG,IAAAA,KAAF;AAASC,IAAAA,YAAT;AAAuBC,IAAAA;AAAvB,MACJP,QAD4C,CAI5CG,OAJF;AAKA,QAAMK,QAAmB,GAAG,EAA5B;AAEA,MAAIC,OAAO,GAAG,EAAd;AAEA,MAAIC,YAAJ;;AACA,MAAI,OAAOX,OAAO,CAACW,YAAf,KAAgC,UAApC,EAAgD;AAC9C;AACAA,IAAAA,YAAY,GAAGX,OAAO,CAACW,YAAvB;AACD,GAHD,MAGO;AACL,YAAQX,OAAO,CAACW,YAAhB;AACE,WAAK,MAAL;AACEA,QAAAA,YAAY,GAAG,CAACC,QAAD,EAAWC,IAAX,KAAqB,GAAED,QAAS,KAAIC,IAAK,KAAxD;;AACA;;AACF,WAAK,QAAL;AACA;AACEC,wBAAOC,GAAP,CAAW,IAAX,EAAiB,CAACC,OAAD,EAAUC,IAAV,KAAmB;AAClC,gBAAM;AAAE7B,YAAAA;AAAF,cAAqBY,OAA3B;;AACA,cAAIgB,OAAO,KAAKtC,kBAAZ,IAAkCU,cAAtC,EAAsD;AACpD;AACA;AACA,mBAAO6B,IAAI,CAACC,OAAL,CACL,mCADK,EAEL,CAACC,KAAD,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB,KACEH,EAAE,GAAGlC,YAAY,CAACoC,EAAD,EAAKlC,cAAL,EAAqBY,OAAO,CAACwB,QAA7B,CAAjB,GAA0DD,EAHvD,CAAP;AAKD;;AAED,iBAAON,IAAP;AACD,SAbD;;AAeAN,QAAAA,YAAY,GAAGG,eAAf;AArBJ;AAuBD;;AAEDW,EAAAA,MAAM,CAACC,IAAP,CAAYpB,KAAZ,EAAmBqB,OAAnB,CAA2B,CAACf,QAAD,EAAWgB,KAAX,KAAqB;AAC9CnB,IAAAA,QAAQ,CAACoB,IAAT,CAAc;AACZC,MAAAA,SAAS,EAAE;AACTC,QAAAA,IAAI,EAAEH,KAAK,GAAG,CADL;AAETI,QAAAA,MAAM,EAAE;AAFC,OADC;AAKZC,MAAAA,QAAQ,EAAE3B,KAAK,CAACM,QAAD,CAAL,CAAgBsB,KALd;AAMZC,MAAAA,IAAI,EAAEvB,QANM;AAOZwB,MAAAA,MAAM,EAAE;AAPI,KAAd;;AAUA,QAAI9B,KAAK,CAACM,QAAD,CAAL,CAAgByB,IAApB,EAA0B;AACxB3B,MAAAA,OAAO,IAAK,GAAEE,QAAS,KAAIN,KAAK,CAACM,QAAD,CAAL,CAAgBF,OAAQ,KAAnD;AACD,KAFD,MAEO;AACL;AACAA,MAAAA,OAAO,IAAK,GAAEC,YAAY,CAACC,QAAD,EAAWN,KAAK,CAACM,QAAD,CAAL,CAAgBF,OAA3B,CAAoC,IAA9D;AACD;AACF,GAjBD;AAmBA,SAAO;AACLd,IAAAA,IAAI,EAAEM,eAAe,IAAI,EADpB;AAELQ,IAAAA,OAFK;AAGLJ,IAAAA,KAHK;AAILC,IAAAA,YAJK;AAKLC,IAAAA,YALK;AAMLH,IAAAA,SAAS,EAAEF,GANN;;AAQL,QAAImC,gBAAJ,GAAuB;AACrB,UAAI7B,QAAJ,aAAIA,QAAJ,eAAIA,QAAQ,CAAE8B,MAAd,EAAsB;AACpB,cAAMC,SAAS,GAAG,IAAIC,6BAAJ,CAAuB;AACvCC,UAAAA,IAAI,EAAE1C,OAAO,CAACwB,QAAR,CAAiBN,OAAjB,CAAyB,OAAzB,EAAkC,MAAlC;AADiC,SAAvB,CAAlB;AAIAT,QAAAA,QAAQ,CAACkB,OAAT,CAAkBgB,OAAD,IACfH,SAAS,CAACI,UAAV,CACEnB,MAAM,CAACoB,MAAP,CAAc,EAAd,EAAkBF,OAAlB,EAA2B;AAAEP,UAAAA,MAAM,EAAEpC,OAAO,CAACwB;AAAlB,SAA3B,CADF,CADF;AAMAgB,QAAAA,SAAS,CAACM,gBAAV,CAA2B9C,OAAO,CAACwB,QAAnC,EAA6C5B,IAA7C;AAEA,eAAO4C,SAAS,CAACO,QAAV,EAAP;AACD;;AAED,aAAO,EAAP;AACD;;AA1BI,GAAP;AA4BD;;AAEc,SAASC,SAAT,CAAmBpD,IAAnB,EAAiCI,OAAjC,EAA2D;AAAA;;AACxE;AACA;AACA,MAAI,CAACL,mBAAmB,CAACC,IAAD,CAAxB,EAAgC;AAC9B,WAAO;AACLA,MAAAA,IADK;AAELS,MAAAA,SAAS,EAAEL,OAAO,CAACiD;AAFd,KAAP;AAID;;AAED,qBACE,WADF,EAEG,GAAEjD,OAAO,CAACwB,QAAS,OAAMxB,OAAO,CAACZ,cAAe,KAAIQ,IAAK,EAF5D;AAKA,QAAMsD,aAAa,GAAG,0BAAYlD,OAAO,CAACkD,aAApB,CAAtB;AACA,QAAMC,YAAY,4BAAGD,aAAH,aAAGA,aAAH,uBAAGA,aAAa,CAAEC,YAAlB,yEAAkC,IAApD,CAhBwE,CAkBxE;AACA;;AACA,QAAMC,GAAG,GAAG,qBAAUxD,IAAV,EAAgB,EAC1B,GAAGuD,YADuB;AAE1B3B,IAAAA,QAAQ,EAAExB,OAAO,CAACwB,QAFQ;AAG1B6B,IAAAA,MAAM,EAAE;AAAElB,MAAAA,IAAI,EAAE;AAAR;AAHkB,GAAhB,CAAZ;AAMA,QAAMpC,eAAe,GAAG,gCAAqBqD,GAArB,EAA2BxD,IAA3B,EAAiC,EACvD,IAAIuD,YAAY,SAAZ,IAAAA,YAAY,WAAZ,IAAAA,YAAY,CAAEG,QAAd,GAAyB;AAAEA,MAAAA,QAAQ,EAAEH,YAAY,CAACG;AAAzB,KAAzB,GAA+D,IAAnE,CADuD;AAEvD9B,IAAAA,QAAQ,EAAExB,OAAO,CAACwB,QAFqC;AAGvD+B,IAAAA,OAAO,EAAE,CAAC,CAACxE,WAAD,EAAcmE,aAAd,CAAD,CAH8C;AAIvDM,IAAAA,OAAO,EAAE,KAJ8C;AAKvDC,IAAAA,UAAU,EAAE,KAL2C;AAMvDC,IAAAA,UAAU,EAAE,IAN2C;AAOvDC,IAAAA,cAAc,EAAE3D,OAAO,CAACwB,QAP+B;AAQvDyB,IAAAA,cAAc,EAAEjD,OAAO,CAACiD;AAR+B,GAAjC,CAAxB;AAWA,SAAOnD,iBAAiB,CAACC,eAAD,EAAkBH,IAAlB,EAAwBI,OAAxB,CAAxB;AACD","sourcesContent":["/**\n * This file exposes transform function that:\n * - parse the passed code to AST\n * - transforms the AST using Linaria babel preset ('./babel/index.js) and additional config defined in Linaria config file or passed to bundler configuration.\n * - runs generated CSS files through default of user-defined preprocessor\n * - generates source maps for CSS files\n * - return transformed code (without Linaria template literals), generated CSS, source maps and babel metadata from transform step.\n */\n\nimport path from 'path';\nimport type { BabelFileMetadata, BabelFileResult } from '@babel/core';\nimport { parseSync, transformFromAstSync } from '@babel/core';\nimport stylis from 'stylis';\nimport type { Mapping } from 'source-map';\nimport { SourceMapGenerator } from 'source-map';\nimport { debug } from '@linaria/logger';\nimport loadOptions from './utils/loadOptions';\nimport type { LinariaMetadata, Options, PreprocessorFn, Result } from './types';\n\nconst STYLIS_DECLARATION = 1;\nconst posixSep = path.posix.sep;\nconst babelPreset = require.resolve('./index');\n\nexport function transformUrl(\n  url: string,\n  outputFilename: string,\n  sourceFilename: string,\n  platformPath: typeof path = path\n) {\n  // Replace asset path with new path relative to the output CSS\n  const relative = platformPath.relative(\n    platformPath.dirname(outputFilename),\n    // Get the absolute path to the asset from the path relative to the JS file\n    platformPath.resolve(platformPath.dirname(sourceFilename), url)\n  );\n\n  if (platformPath.sep === posixSep) {\n    return relative;\n  }\n\n  return relative.split(platformPath.sep).join(posixSep);\n}\n\nexport function shouldTransformCode(code: string): boolean {\n  return /\\b(styled|css)/.test(code);\n}\n\nexport function extractCssFromAst(\n  babelFileResult: BabelFileResult,\n  code: string,\n  options: Options\n): Result {\n  const { metadata, code: transformedCode, map } = babelFileResult;\n\n  if (\n    !metadata ||\n    !(metadata as BabelFileMetadata & { linaria: LinariaMetadata }).linaria\n  ) {\n    return {\n      code: transformedCode || '', // if there was only unused code we want to return transformed code which will be later removed by the bundler\n      sourceMap: map,\n    };\n  }\n\n  const { rules, replacements, dependencies } = (\n    metadata as BabelFileMetadata & {\n      linaria: LinariaMetadata;\n    }\n  ).linaria;\n  const mappings: Mapping[] = [];\n\n  let cssText = '';\n\n  let preprocessor: PreprocessorFn;\n  if (typeof options.preprocessor === 'function') {\n    // eslint-disable-next-line prefer-destructuring\n    preprocessor = options.preprocessor;\n  } else {\n    switch (options.preprocessor) {\n      case 'none':\n        preprocessor = (selector, text) => `${selector} {${text}}\\n`;\n        break;\n      case 'stylis':\n      default:\n        stylis.use(null)((context, decl) => {\n          const { outputFilename } = options;\n          if (context === STYLIS_DECLARATION && outputFilename) {\n            // When writing to a file, we need to adjust the relative paths inside url(..) expressions\n            // It'll allow css-loader to resolve an imported asset properly\n            return decl.replace(\n              /\\b(url\\(([\"']?))(\\.[^)]+?)(\\2\\))/g,\n              (match, p1, p2, p3, p4) =>\n                p1 + transformUrl(p3, outputFilename, options.filename) + p4\n            );\n          }\n\n          return decl;\n        });\n\n        preprocessor = stylis;\n    }\n  }\n\n  Object.keys(rules).forEach((selector, index) => {\n    mappings.push({\n      generated: {\n        line: index + 1,\n        column: 0,\n      },\n      original: rules[selector].start!,\n      name: selector,\n      source: '',\n    });\n\n    if (rules[selector].atom) {\n      cssText += `${selector} {${rules[selector].cssText}}\\n`;\n    } else {\n      // Run each rule through stylis to support nesting\n      cssText += `${preprocessor(selector, rules[selector].cssText)}\\n`;\n    }\n  });\n\n  return {\n    code: transformedCode || '',\n    cssText,\n    rules,\n    replacements,\n    dependencies,\n    sourceMap: map,\n\n    get cssSourceMapText() {\n      if (mappings?.length) {\n        const generator = new SourceMapGenerator({\n          file: options.filename.replace(/\\.js$/, '.css'),\n        });\n\n        mappings.forEach((mapping) =>\n          generator.addMapping(\n            Object.assign({}, mapping, { source: options.filename })\n          )\n        );\n\n        generator.setSourceContent(options.filename, code);\n\n        return generator.toString();\n      }\n\n      return '';\n    },\n  };\n}\n\nexport default function transform(code: string, options: Options): Result {\n  // Check if the file contains `css` or `styled` words first\n  // Otherwise we should skip transforming\n  if (!shouldTransformCode(code)) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  debug(\n    'transform',\n    `${options.filename} to ${options.outputFilename}\\n${code}`\n  );\n\n  const pluginOptions = loadOptions(options.pluginOptions);\n  const babelOptions = pluginOptions?.babelOptions ?? null;\n\n  // Parse the code first so babel uses user's babel config for parsing\n  // We don't want to use user's config when transforming the code\n  const ast = parseSync(code, {\n    ...babelOptions,\n    filename: options.filename,\n    caller: { name: 'linaria' },\n  });\n\n  const babelFileResult = transformFromAstSync(ast!, code, {\n    ...(babelOptions?.rootMode ? { rootMode: babelOptions.rootMode } : null),\n    filename: options.filename,\n    presets: [[babelPreset, pluginOptions]],\n    babelrc: false,\n    configFile: false,\n    sourceMaps: true,\n    sourceFileName: options.filename,\n    inputSourceMap: options.inputSourceMap,\n  })!;\n\n  return extractCssFromAst(babelFileResult, code, options);\n}\n"],"file":"transform.js"}