{"version":3,"sources":["../src/extract.ts"],"names":["isLazyValue","v","kind","ValueType","LAZY","isNodePath","obj","node","undefined","findFreeName","scope","name","nextName","idx","hasBinding","unwrapNode","item","expressionWrapperTpl","expressionTpl","exportsLinariaPrevalTpl","addLinariaPreval","types","t","path","lazyDeps","wrapName","statements","expressions","arrayExpression","map","expression","programNode","program","body","directives","sourceType","interpreter","extract","babel","options","process","visitor","Program","enter","state","queue","rules","index","dependencies","replacements","file","opts","filename","Module","invalidate","traverse","ImportDeclaration","p","TaggedTemplateExpression","reduce","acc","expressionValues","values","push","filter","expressionsToEvaluate","ex","originalLazyExpressions","originalEx","length","lazyValues","code","evaluation","value","__linariaPreval","e","Error","stack","valueCache","Map","forEach","key","set","exit","_","Object","keys","metadata","linaria"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\n\n/**\n * This is an entry point for styles extraction.\n * On enter, It:\n *  - traverse the code using visitors (TaggedTemplateExpression, ImportDeclaration)\n *  - schedule evaluation of lazy dependencies (those who are not simple expressions //TODO does they have it's name?)\n *  - let templateProcessor to save evaluated values in babel state as `replacements`.\n * On exit, It:\n *  - store result of extraction in babel's file metadata\n */\n\nimport type { Node, Program, Expression } from '@babel/types';\nimport type { NodePath, Scope, Visitor } from '@babel/traverse';\nimport { expression, statement } from '@babel/template';\nimport generator from '@babel/generator';\nimport { debug, error } from '@linaria/logger';\nimport evaluate from './evaluators';\nimport getTemplateProcessor from './evaluators/templateProcessor';\nimport Module from './module';\nimport type {\n  State,\n  StrictOptions,\n  LazyValue,\n  ExpressionValue,\n  ValueCache,\n} from './types';\nimport { ValueType } from './types';\nimport CollectDependencies from './visitors/CollectDependencies';\nimport DetectStyledImportName from './visitors/DetectStyledImportName';\nimport GenerateClassNames from './visitors/GenerateClassNames';\nimport type { Core } from './babel';\n\nfunction isLazyValue(v: ExpressionValue): v is LazyValue {\n  return v.kind === ValueType.LAZY;\n}\n\nfunction isNodePath<T extends Node>(obj: NodePath<T> | T): obj is NodePath<T> {\n  return 'node' in obj && obj?.node !== undefined;\n}\n\nfunction findFreeName(scope: Scope, name: string): string {\n  // By default `name` is used as a name of the function …\n  let nextName = name;\n  let idx = 0;\n  while (scope.hasBinding(nextName, false)) {\n    // … but if there is an already defined variable with this name …\n    // … we are trying to use a name like wrap_N\n    idx += 1;\n    nextName = `wrap_${idx}`;\n  }\n\n  return nextName;\n}\n\nfunction unwrapNode<T extends Node>(\n  item: NodePath<T> | T | string\n): T | string {\n  if (typeof item === 'string') {\n    return item;\n  }\n\n  return isNodePath(item) ? item.node : item;\n}\n\n// All exported values will be wrapped with this function\nconst expressionWrapperTpl = statement(`\n  const %%wrapName%% = (fn) => {\n    try {\n      return fn();\n    } catch (e) {\n      return e;\n    }\n  };\n`);\n\nconst expressionTpl = expression(`%%wrapName%%(() => %%expression%%)`);\nconst exportsLinariaPrevalTpl = statement(\n  `exports.__linariaPreval = %%expressions%%`\n);\n\nfunction addLinariaPreval(\n  { types: t }: Core,\n  path: NodePath<Program>,\n  lazyDeps: Array<Expression | string>\n): Program {\n  // Constant __linariaPreval with all dependencies\n  const wrapName = findFreeName(path.scope, '_wrap');\n  const statements = [\n    expressionWrapperTpl({ wrapName }),\n    exportsLinariaPrevalTpl({\n      expressions: t.arrayExpression(\n        lazyDeps.map((expression) => expressionTpl({ expression, wrapName }))\n      ),\n    }),\n  ];\n\n  const programNode = path.node;\n  return t.program(\n    [...programNode.body, ...statements],\n    programNode.directives,\n    programNode.sourceType,\n    programNode.interpreter\n  );\n}\n\nexport default function extract(\n  babel: Core,\n  options: StrictOptions\n): { visitor: Visitor<State> } {\n  const process = getTemplateProcessor(babel, options);\n\n  return {\n    visitor: {\n      Program: {\n        enter(path: NodePath<Program>, state: State) {\n          // Collect all the style rules from the styles we encounter\n          state.queue = [];\n          state.rules = {};\n          state.index = -1;\n          state.dependencies = [];\n          state.replacements = [];\n          debug('extraction:start', state.file.opts.filename);\n\n          // Invalidate cache for module evaluation to get fresh modules\n          Module.invalidate();\n\n          // We need our transforms to run before anything else\n          // So we traverse here instead of a in a visitor\n          path.traverse({\n            ImportDeclaration: (p) => DetectStyledImportName(babel, p, state),\n            TaggedTemplateExpression: (p) => {\n              GenerateClassNames(babel, p, state, options);\n              CollectDependencies(babel, p, state, options);\n            },\n          });\n\n          const lazyDeps = state.queue.reduce(\n            (acc, { expressionValues: values }) => {\n              acc.push(...values.filter(isLazyValue));\n              return acc;\n            },\n            [] as LazyValue[]\n          );\n\n          const expressionsToEvaluate = lazyDeps.map((v) => unwrapNode(v.ex));\n          const originalLazyExpressions = lazyDeps.map((v) =>\n            unwrapNode(v.originalEx)\n          );\n\n          debug('lazy-deps:count', lazyDeps.length);\n\n          let lazyValues: any[] = [];\n\n          if (expressionsToEvaluate.length > 0) {\n            debug(\n              'lazy-deps:original-expressions-list',\n              originalLazyExpressions.map((node) =>\n                typeof node !== 'string' ? generator(node).code : node\n              )\n            );\n            debug(\n              'lazy-deps:expressions-to-eval-list',\n              expressionsToEvaluate.map((node) =>\n                typeof node !== 'string' ? generator(node).code : node\n              )\n            );\n\n            const program = addLinariaPreval(\n              babel,\n              path,\n              expressionsToEvaluate\n            );\n            const { code } = generator(program);\n            debug('lazy-deps:evaluate', '');\n            try {\n              const evaluation = evaluate(\n                code,\n                state.file.opts.filename,\n                options\n              );\n              debug('lazy-deps:sub-files', evaluation.dependencies);\n\n              state.dependencies.push(...evaluation.dependencies);\n              lazyValues = evaluation.value.__linariaPreval || [];\n              debug('lazy-deps:values', evaluation.value.__linariaPreval);\n            } catch (e) {\n              error('lazy-deps:evaluate:error', code);\n              throw new Error(\n                'An unexpected runtime error occurred during dependencies evaluation: \\n' +\n                  e.stack +\n                  '\\n\\nIt may happen when your code or third party module is invalid or uses identifiers not available in Node environment, eg. window. \\n' +\n                  'Note that line numbers in above stack trace will most likely not match, because Linaria needed to transform your code a bit.\\n'\n              );\n            }\n          }\n\n          const valueCache: ValueCache = new Map();\n          originalLazyExpressions.forEach((key, idx) =>\n            valueCache.set(key, lazyValues[idx])\n          );\n          state.queue.forEach((item) => process(item, state, valueCache));\n        },\n        exit(_: any, state: State) {\n          if (Object.keys(state.rules).length) {\n            // Store the result as the file metadata under linaria key\n            state.file.metadata.linaria = {\n              rules: state.rules,\n              replacements: state.replacements,\n              dependencies: state.dependencies,\n            };\n          }\n\n          // Invalidate cache for module evaluation when we're done\n          Module.invalidate();\n\n          debug('extraction:end', state.file.opts.filename);\n        },\n      },\n    },\n  };\n}\n"],"file":"extract.js"}