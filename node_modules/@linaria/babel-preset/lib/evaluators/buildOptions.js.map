{"version":3,"file":"buildOptions.js","names":["buildOptions","filename","options","plugins","defaults","caller","name","evaluate","presets","require","resolve","map","babelOptions","keys","forEach","field","filter","item","Array","isArray","includes","some","it"],"sources":["../../src/evaluators/buildOptions.ts"],"sourcesContent":["/**\n * This file handles preparing babel config for Linaria preevaluation.\n */\n\nimport type { PluginItem, TransformOptions } from '@babel/core';\n\nimport type { StrictOptions } from '../types';\n\ntype DefaultOptions = Partial<TransformOptions> & {\n  plugins: PluginItem[];\n  presets: PluginItem[];\n  caller: { evaluate: boolean };\n};\n\nexport default function buildOptions(\n  filename: string,\n  options?: StrictOptions\n): TransformOptions {\n  const plugins: Array<string | object> = [\n    // Include these plugins to avoid extra config when using { module: false } for webpack\n    '@babel/plugin-transform-modules-commonjs',\n    '@babel/plugin-proposal-export-namespace-from',\n  ];\n\n  const defaults: DefaultOptions = {\n    caller: { name: 'linaria', evaluate: true },\n    filename,\n    presets: [\n      [\n        require.resolve('../index'),\n        {\n          ...(options || {}),\n        },\n      ],\n    ],\n    plugins: [\n      ...plugins.map((name) => require.resolve(name as string)),\n      // We don't support dynamic imports when evaluating, but don't wanna syntax error\n      // This will replace dynamic imports with an object that does nothing\n      require.resolve('../dynamic-import-noop'),\n    ],\n  };\n\n  const babelOptions =\n    // Shallow copy the babel options because we mutate it later\n    options?.babelOptions ? { ...options.babelOptions } : {};\n\n  // If we programmatically pass babel options while there is a .babelrc, babel might throw\n  // We need to filter out duplicate presets and plugins so that this doesn't happen\n  // This workaround isn't full proof, but it's still better than nothing\n  const keys: Array<keyof TransformOptions & ('presets' | 'plugins')> = [\n    'presets',\n    'plugins',\n  ];\n  keys.forEach((field) => {\n    babelOptions[field] = babelOptions[field]\n      ? babelOptions[field]!.filter((item: PluginItem) => {\n          // If item is an array it's a preset/plugin with options ([preset, options])\n          // Get the first item to get the preset.plugin name\n          // Otherwise it's a plugin name (can be a function too)\n          const name = Array.isArray(item) ? item[0] : item;\n\n          if (\n            // In our case, a preset might also be referring to linaria/babel\n            // We require the file from internal path which is not the same one that we export\n            // This case won't get caught and the preset won't filtered, even if they are same\n            // So we add an extra check for top level linaria/babel\n            name === 'linaria/babel' ||\n            name === '@linaria' ||\n            name === '@linaria/babel-preset' ||\n            name === require.resolve('../index') ||\n            // Also add a check for the plugin names we include for bundler support\n            plugins.includes(name)\n          ) {\n            return false;\n          }\n\n          // Loop through the default presets/plugins to see if it already exists\n          return !defaults[field].some((it) =>\n            // The default presets/plugins can also have nested arrays,\n            Array.isArray(it) ? it[0] === name : it === name\n          );\n        })\n      : [];\n  });\n\n  return {\n    // Passed options shouldn't be able to override the options we pass\n    // Linaria's plugins rely on these (such as filename to generate consistent hash)\n    ...babelOptions,\n    ...defaults,\n    presets: [\n      // Preset order is last to first, so add the extra presets to start\n      // This makes sure that our preset is always run first\n      ...babelOptions.presets!,\n      ...defaults.presets,\n    ],\n    plugins: [\n      ...defaults.plugins,\n      // Plugin order is first to last, so add the extra presets to end\n      // This makes sure that the plugins we specify always run first\n      ...babelOptions.plugins!,\n    ],\n  };\n}\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AAYe,SAASA,YAAT,CACbC,QADa,EAEbC,OAFa,EAGK;EAClB,MAAMC,OAA+B,GAAG,CACtC;EACA,0CAFsC,EAGtC,8CAHsC,CAAxC;EAMA,MAAMC,QAAwB,GAAG;IAC/BC,MAAM,EAAE;MAAEC,IAAI,EAAE,SAAR;MAAmBC,QAAQ,EAAE;IAA7B,CADuB;IAE/BN,QAF+B;IAG/BO,OAAO,EAAE,CACP,CACEC,OAAO,CAACC,OAAR,CAAgB,UAAhB,CADF,EAEE,EACE,IAAIR,OAAO,IAAI,EAAf;IADF,CAFF,CADO,CAHsB;IAW/BC,OAAO,EAAE,CACP,GAAGA,OAAO,CAACQ,GAAR,CAAaL,IAAD,IAAUG,OAAO,CAACC,OAAR,CAAgBJ,IAAhB,CAAtB,CADI,EAEP;IACA;IACAG,OAAO,CAACC,OAAR,CAAgB,wBAAhB,CAJO;EAXsB,CAAjC;EAmBA,MAAME,YAAY,GAChB;EACAV,OAAO,SAAP,IAAAA,OAAO,WAAP,IAAAA,OAAO,CAAEU,YAAT,GAAwB,EAAE,GAAGV,OAAO,CAACU;EAAb,CAAxB,GAAsD,EAFxD,CA1BkB,CA8BlB;EACA;EACA;;EACA,MAAMC,IAA6D,GAAG,CACpE,SADoE,EAEpE,SAFoE,CAAtE;EAIAA,IAAI,CAACC,OAAL,CAAcC,KAAD,IAAW;IACtBH,YAAY,CAACG,KAAD,CAAZ,GAAsBH,YAAY,CAACG,KAAD,CAAZ,GAClBH,YAAY,CAACG,KAAD,CAAZ,CAAqBC,MAArB,CAA6BC,IAAD,IAAsB;MAChD;MACA;MACA;MACA,MAAMX,IAAI,GAAGY,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAI,CAAC,CAAD,CAA1B,GAAgCA,IAA7C;;MAEA,KACE;MACA;MACA;MACA;MACAX,IAAI,KAAK,eAAT,IACAA,IAAI,KAAK,UADT,IAEAA,IAAI,KAAK,uBAFT,IAGAA,IAAI,KAAKG,OAAO,CAACC,OAAR,CAAgB,UAAhB,CAHT,IAIA;MACAP,OAAO,CAACiB,QAAR,CAAiBd,IAAjB,CAVF,EAWE;QACA,OAAO,KAAP;MACD,CAnB+C,CAqBhD;;;MACA,OAAO,CAACF,QAAQ,CAACW,KAAD,CAAR,CAAgBM,IAAhB,CAAsBC,EAAD,IAC3B;MACAJ,KAAK,CAACC,OAAN,CAAcG,EAAd,IAAoBA,EAAE,CAAC,CAAD,CAAF,KAAUhB,IAA9B,GAAqCgB,EAAE,KAAKhB,IAFtC,CAAR;IAID,CA1BD,CADkB,GA4BlB,EA5BJ;EA6BD,CA9BD;EAgCA,OAAO,EACL;IACA;IACA,GAAGM,YAHE;IAIL,GAAGR,QAJE;IAKLI,OAAO,EAAE,CACP;IACA;IACA,GAAGI,YAAY,CAACJ,OAHT,EAIP,GAAGJ,QAAQ,CAACI,OAJL,CALJ;IAWLL,OAAO,EAAE,CACP,GAAGC,QAAQ,CAACD,OADL,EAEP;IACA;IACA,GAAGS,YAAY,CAACT,OAJT;EAXJ,CAAP;AAkBD"}