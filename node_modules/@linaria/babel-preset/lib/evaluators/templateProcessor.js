"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getTemplateProcessor;

var _units = require("../units");

var _getTagProcessor = _interopRequireDefault(require("../utils/getTagProcessor"));

var _isSerializable = _interopRequireDefault(require("../utils/isSerializable"));

var _stripLines = _interopRequireDefault(require("../utils/stripLines"));

var _toCSS = _interopRequireDefault(require("../utils/toCSS"));

var _unwrapNode = _interopRequireDefault(require("../utils/unwrapNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This file handles transforming template literals to class names or styled components and generates CSS content.
 * It uses CSS code from template literals and evaluated values of lazy dependencies stored in ValueCache.
 */
// Match any valid CSS units followed by a separator such as ;, newline etc.
const unitRegex = new RegExp(`^(${_units.units.join('|')})(;|,|\n| |\\))`);

function hasMeta(value) {
  return typeof value === 'object' && value !== null && '__linaria' in value;
}

const processedPaths = new WeakSet();
/**
 * De-duplicate interpolations based on the source and unit
 * If two interpolations have the same source code and same unit,
 * we don't need to use 2 custom properties for them, we can use a single one
 * @param interpolations
 */

function dedupInterpolations(interpolations) {
  const interpolationsObj = {};
  const replacements = [];
  interpolations.forEach(it => {
    const key = it.source + it.unit;

    if (key in interpolationsObj) {
      replacements.push([`var(--${it.id})`, `var(--${interpolationsObj[key].id})`]);
    } else {
      interpolationsObj[key] = it;
    }
  });
  return [Object.values(interpolationsObj), replacements];
}

function getTemplateProcessor(options) {
  return function process({
    path,
    quasis,
    expressions
  }, state, valueCache) {
    var _path$parent;

    if (processedPaths.has(path)) {
      // Do not process an expression
      // if it is referenced in one template more than once
      return;
    }

    processedPaths.add(path);
    const tagProcessor = (0, _getTagProcessor.default)(path, state, options);

    if (!tagProcessor) {
      return;
    } // Check if the variable is referenced anywhere for basic DCE
    // Only works when it's assigned to a variable


    let isReferenced = true;
    const parent = path.findParent(p => p.isObjectProperty() || p.isJSXOpeningElement() || p.isVariableDeclarator());

    if (parent) {
      if (parent.isVariableDeclarator()) {
        const id = parent.get('id');

        if (id.isIdentifier()) {
          const {
            referencePaths
          } = path.scope.getBinding(id.node.name) || {
            referencePaths: []
          };
          isReferenced = referencePaths.length !== 0;
        }
      }
    } // Serialize the tagged template literal to a string


    let cssText = '';
    const {
      length
    } = quasis;
    const queue = [];

    for (let i = 0; i < length; i++) {
      const value = i < length - 1 ? expressions[i] : null;
      queue.push([quasis[i].node, value]);
    }

    queue.forEach(([el, expressionValue], i, self) => {
      let appended = false;

      if (i !== 0 && el.value.cooked) {
        // Check if previous expression was a CSS variable that we replaced
        // If it has a unit after it, we need to move the unit into the interpolation
        // e.g. `var(--size)px` should actually be `var(--size)`
        // So we check if the current text starts with a unit, and add the unit to the previous interpolation
        // Another approach would be `calc(var(--size) * 1px), but some browsers don't support all units
        // https://bugzilla.mozilla.org/show_bug.cgi?id=956573
        const matches = el.value.cooked.match(unitRegex);

        if (matches) {
          const last = tagProcessor.lastInterpolation;
          const [, unit] = matches;

          if (last && cssText.endsWith(`var(--${last.id})`)) {
            last.unit = unit;
            cssText += el.value.cooked.replace(unitRegex, '$2');
            appended = true;
          }
        }
      }

      if (!appended) {
        cssText += el.value.cooked;
      }

      if (expressionValue) {
        var _self;

        const ex = 'originalEx' in expressionValue ? expressionValue.originalEx : expressionValue.ex;
        const exNode = (0, _unwrapNode.default)(ex);
        const {
          end
        } = exNode.loc;
        const beforeLength = cssText.length; // The location will be end of the current string to start of next string

        const next = (_self = self[i + 1]) === null || _self === void 0 ? void 0 : _self[0];
        const loc = {
          // +1 because the expressions location always shows 1 column before
          start: {
            line: el.loc.end.line,
            column: el.loc.end.column + 1
          },
          end: next ? {
            line: next.loc.start.line,
            column: next.loc.start.column
          } : {
            line: end.line,
            column: end.column + 1
          }
        };
        const value = valueCache.get(exNode);

        if (value && typeof value !== 'function') {
          // Skip the blank string instead of throw ing an error
          if (value === '') {
            return;
          }

          if (hasMeta(value)) {
            // If it's an React component wrapped in styled, get the class name
            // Useful for interpolating components
            cssText += `.${value.__linaria.className}`;
          } else if ((0, _isSerializable.default)(value)) {
            // If it's a plain object or an array, convert it to a CSS string
            cssText += (0, _stripLines.default)(loc, (0, _toCSS.default)(value));
          } else {
            // For anything else, assume it'll be stringified
            cssText += (0, _stripLines.default)(loc, value);
          }

          state.replacements.push({
            original: loc,
            length: cssText.length - beforeLength
          });
          return;
        }

        try {
          const {
            ex: expression
          } = expressionValue;
          cssText += tagProcessor.addInterpolation('node' in expression ? expression.node : expression, expressionValue.source);
        } catch (e) {
          if (e instanceof Error && 'buildCodeFrameError' in ex) {
            throw ex.buildCodeFrameError(e.message);
          }

          throw e;
        }
      }
    });
    const [uniqInterpolations, replacements] = dedupInterpolations(tagProcessor.interpolations);
    replacements.forEach(([s, r]) => {
      cssText = cssText.replace(s, r);
    });
    const [rules, classes] = tagProcessor.extractRules(valueCache, cssText, (_path$parent = path.parent) === null || _path$parent === void 0 ? void 0 : _path$parent.loc);
    const [replacement, isPure] = tagProcessor.getRuntimeReplacement(classes, uniqInterpolations);
    path.replaceWith(replacement);

    if (isPure) {
      path.addComment('leading', '#__PURE__');
    }

    if (!isReferenced && !cssText.includes(':global')) {
      return;
    } // eslint-disable-next-line no-param-reassign


    state.rules = { ...state.rules,
      ...rules
    };
  };
}
//# sourceMappingURL=templateProcessor.js.map