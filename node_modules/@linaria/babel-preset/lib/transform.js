"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformUrl = transformUrl;
exports.shouldTransformCode = shouldTransformCode;
exports.extractCssFromAst = extractCssFromAst;
exports.default = transform;

var _path = _interopRequireDefault(require("path"));

var _core = require("@babel/core");

var _stylis = _interopRequireDefault(require("stylis"));

var _sourceMap = require("source-map");

var _logger = require("@linaria/logger");

var _loadOptions = _interopRequireDefault(require("./utils/loadOptions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This file exposes transform function that:
 * - parse the passed code to AST
 * - transforms the AST using Linaria babel preset ('./babel/index.js) and additional config defined in Linaria config file or passed to bundler configuration.
 * - runs generated CSS files through default of user-defined preprocessor
 * - generates source maps for CSS files
 * - return transformed code (without Linaria template literals), generated CSS, source maps and babel metadata from transform step.
 */
const STYLIS_DECLARATION = 1;
const posixSep = _path.default.posix.sep;

const babelPreset = require.resolve('./index');

function transformUrl(url, outputFilename, sourceFilename, platformPath = _path.default) {
  // Replace asset path with new path relative to the output CSS
  const relative = platformPath.relative(platformPath.dirname(outputFilename), // Get the absolute path to the asset from the path relative to the JS file
  platformPath.resolve(platformPath.dirname(sourceFilename), url));

  if (platformPath.sep === posixSep) {
    return relative;
  }

  return relative.split(platformPath.sep).join(posixSep);
}

function shouldTransformCode(code) {
  return /\b(styled|css)/.test(code);
}

function extractCssFromAst(babelFileResult, code, options) {
  const {
    metadata,
    code: transformedCode,
    map
  } = babelFileResult;

  if (!metadata || !metadata.linaria) {
    return {
      code: transformedCode || '',
      // if there was only unused code we want to return transformed code which will be later removed by the bundler
      sourceMap: map
    };
  }

  const {
    rules,
    replacements,
    dependencies
  } = metadata.linaria;
  const mappings = [];
  let cssText = '';
  let preprocessor;

  if (typeof options.preprocessor === 'function') {
    // eslint-disable-next-line prefer-destructuring
    preprocessor = options.preprocessor;
  } else {
    switch (options.preprocessor) {
      case 'none':
        preprocessor = (selector, text) => `${selector} {${text}}\n`;

        break;

      case 'stylis':
      default:
        _stylis.default.use(null)((context, decl) => {
          const {
            outputFilename
          } = options;

          if (context === STYLIS_DECLARATION && outputFilename) {
            // When writing to a file, we need to adjust the relative paths inside url(..) expressions
            // It'll allow css-loader to resolve an imported asset properly
            return decl.replace(/\b(url\((["']?))(\.[^)]+?)(\2\))/g, (match, p1, p2, p3, p4) => p1 + transformUrl(p3, outputFilename, options.filename) + p4);
          }

          return decl;
        });

        preprocessor = _stylis.default;
    }
  }

  Object.keys(rules).forEach((selector, index) => {
    mappings.push({
      generated: {
        line: index + 1,
        column: 0
      },
      original: rules[selector].start,
      name: selector,
      source: ''
    });

    if (rules[selector].atom) {
      cssText += `${selector} {${rules[selector].cssText}}\n`;
    } else {
      // Run each rule through stylis to support nesting
      cssText += `${preprocessor(selector, rules[selector].cssText)}\n`;
    }
  });
  return {
    code: transformedCode || '',
    cssText,
    rules,
    replacements,
    dependencies,
    sourceMap: map,

    get cssSourceMapText() {
      if (mappings !== null && mappings !== void 0 && mappings.length) {
        const generator = new _sourceMap.SourceMapGenerator({
          file: options.filename.replace(/\.js$/, '.css')
        });
        mappings.forEach(mapping => generator.addMapping(Object.assign({}, mapping, {
          source: options.filename
        })));
        generator.setSourceContent(options.filename, code);
        return generator.toString();
      }

      return '';
    }

  };
}

function transform(code, options) {
  var _pluginOptions$babelO;

  // Check if the file contains `css` or `styled` words first
  // Otherwise we should skip transforming
  if (!shouldTransformCode(code)) {
    return {
      code,
      sourceMap: options.inputSourceMap
    };
  }

  (0, _logger.debug)('transform', `${options.filename} to ${options.outputFilename}\n${code}`);
  const pluginOptions = (0, _loadOptions.default)(options.pluginOptions);
  const babelOptions = (_pluginOptions$babelO = pluginOptions === null || pluginOptions === void 0 ? void 0 : pluginOptions.babelOptions) !== null && _pluginOptions$babelO !== void 0 ? _pluginOptions$babelO : null; // Parse the code first so babel uses user's babel config for parsing
  // We don't want to use user's config when transforming the code

  const ast = (0, _core.parseSync)(code, { ...babelOptions,
    filename: options.filename,
    caller: {
      name: 'linaria'
    }
  });
  const babelFileResult = (0, _core.transformFromAstSync)(ast, code, { ...(babelOptions !== null && babelOptions !== void 0 && babelOptions.rootMode ? {
      rootMode: babelOptions.rootMode
    } : null),
    filename: options.filename,
    presets: [[babelPreset, pluginOptions]],
    babelrc: false,
    configFile: false,
    sourceMaps: true,
    sourceFileName: options.filename,
    inputSourceMap: options.inputSourceMap
  });
  return extractCssFromAst(babelFileResult, code, options);
}
//# sourceMappingURL=transform.js.map