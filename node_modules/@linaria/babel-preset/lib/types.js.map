{"version":3,"file":"types.js","names":["ValueType"],"sources":["../src/types.ts"],"sourcesContent":["import type { TransformOptions } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  Expression,\n  TaggedTemplateExpression,\n  TemplateElement,\n} from '@babel/types';\nimport type { RawSourceMap } from 'source-map';\n\nimport type { Value } from '@linaria/core/processors/types';\nimport type { ClassNameFn } from '@linaria/core/processors/utils/types';\n\nimport type { PluginOptions } from './utils/loadOptions';\n\nexport type {\n  JSONValue,\n  JSONObject,\n  JSONArray,\n  Serializable,\n  Value,\n  ValueCache,\n} from '@linaria/core/processors/types';\n\nexport enum ValueType {\n  LAZY,\n  FUNCTION,\n  VALUE,\n}\n\nexport type ComponentDependency = {\n  ex: NodePath<Expression>; // | Expression | string;\n  source: string;\n  value?: string;\n};\n\nexport type LazyValue = {\n  kind: ValueType.LAZY;\n  ex: NodePath<Expression> | Expression; // | string;\n  originalEx: NodePath<Expression>; // | Expression | string;\n  source: string;\n};\n\nexport type FunctionValue = {\n  kind: ValueType.FUNCTION;\n  ex: NodePath<Expression>;\n  source: string;\n};\n\nexport type EvaluatedValue = {\n  kind: ValueType.VALUE;\n  value: Value;\n  ex: NodePath<Expression>;\n  source: string;\n};\n\nexport type ExpressionValue = LazyValue | FunctionValue | EvaluatedValue;\n\nexport type Path = NodePath<TaggedTemplateExpression>;\n\nexport type TemplateExpression = {\n  path: Path;\n  quasis: NodePath<TemplateElement>[];\n  expressions: ExpressionValue[];\n  dependencies: ComponentDependency[];\n};\n\nexport interface ICSSRule {\n  className: string;\n  displayName: string;\n  cssText: string;\n  start: Location | null | undefined;\n  atom?: boolean;\n}\n\nexport type Rules = Record<string, ICSSRule>;\n\ntype Replacements = Array<{\n  original: {\n    start: Location;\n    end: Location;\n  };\n  length: number;\n}>;\n\ntype Dependencies = string[];\n\nexport type State = {\n  queue: TemplateExpression[];\n  rules: Rules;\n  replacements: Replacements;\n  index: number;\n  dependencies: Dependencies;\n  file: {\n    opts: {\n      cwd: string;\n      root: string;\n      filename: string;\n    };\n    metadata: {\n      linaria?: {\n        rules: Rules;\n        replacements: Replacements;\n        dependencies: Dependencies;\n      };\n    };\n  };\n};\n\nexport type Evaluator = (\n  filename: string,\n  options: StrictOptions,\n  text: string,\n  only: string[] | null\n) => [string, Map<string, string[]> | null];\n\nexport type EvalRule = {\n  test?: RegExp | ((path: string) => boolean);\n  action: Evaluator | 'ignore' | string;\n};\n\nexport type LibResolverFn = (linariaLibPath: string) => string | null;\n\nexport type StrictOptions = {\n  classNameSlug?: string | ClassNameFn;\n  displayName: boolean;\n  evaluate: boolean;\n  ignore?: RegExp;\n  babelOptions: TransformOptions;\n  rules: EvalRule[];\n};\n\nexport type Location = {\n  line: number;\n  column: number;\n};\n\nexport type Replacement = {\n  original: { start: Location; end: Location };\n  length: number;\n};\n\nexport type Result = {\n  code: string;\n  sourceMap?: RawSourceMap | null;\n  cssText?: string;\n  cssSourceMapText?: string;\n  dependencies?: string[];\n  rules?: Rules;\n  replacements?: Replacement[];\n};\n\nexport type LinariaMetadata = {\n  rules: Rules;\n  replacements: Replacement[];\n  dependencies: string[];\n};\n\nexport type Options = {\n  filename: string;\n  preprocessor?: Preprocessor;\n  outputFilename?: string;\n  inputSourceMap?: RawSourceMap;\n  pluginOptions?: Partial<PluginOptions>;\n};\n\nexport type PreprocessorFn = (selector: string, cssText: string) => string;\nexport type Preprocessor = 'none' | 'stylis' | PreprocessorFn | void;\n"],"mappings":";;;;;;IAuBYA,S;;;WAAAA,S;EAAAA,S,CAAAA,S;EAAAA,S,CAAAA,S;EAAAA,S,CAAAA,S;GAAAA,S,yBAAAA,S"}