"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extract;

var _logger = require("@linaria/logger");

var _templateProcessor = _interopRequireDefault(require("./evaluators/templateProcessor"));

var _module = _interopRequireDefault(require("./module"));

var _evaluateExpressions = _interopRequireDefault(require("./utils/evaluateExpressions"));

var _processTemplateExpression = _interopRequireDefault(require("./utils/processTemplateExpression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign */

/**
 * This is an entry point for styles extraction.
 * On enter, It:
 *  - traverse the code using visitors (TaggedTemplateExpression, ImportDeclaration)
 *  - schedule evaluation of lazy dependencies (those who are not simple expressions //TODO does they have it's name?)
 *  - let templateProcessor to save evaluated values in babel state as `replacements`.
 * On exit, It:
 *  - store result of extraction in babel's file metadata
 */
function extract(babel, options) {
  const process = (0, _templateProcessor.default)(options);
  return {
    visitor: {
      Program: {
        enter(path, state) {
          // Collect all the style rules from the styles we encounter
          state.queue = [];
          state.rules = {};
          state.index = -1;
          state.dependencies = [];
          state.replacements = [];
          (0, _logger.debug)('extraction:start', state.file.opts.filename); // Invalidate cache for module evaluation to get fresh modules

          _module.default.invalidate(); // We need our transforms to run before anything else
          // So we traverse here instead of a in a visitor


          path.traverse({
            TaggedTemplateExpression: p => {
              (0, _processTemplateExpression.default)(babel, 'extract', p, state, options);
            }
          });
          const [dependencies, valueCache] = (0, _evaluateExpressions.default)(babel, path, state.queue, options, state.file.opts.filename);
          state.dependencies.push(...dependencies);
          state.queue.forEach(item => process(item, state, valueCache));
        },

        exit(_, state) {
          if (Object.keys(state.rules).length) {
            // Store the result as the file metadata under linaria key
            state.file.metadata.linaria = {
              rules: state.rules,
              replacements: state.replacements,
              dependencies: state.dependencies
            };
          } // Invalidate cache for module evaluation when we're done


          _module.default.invalidate();

          (0, _logger.debug)('extraction:end', state.file.opts.filename);
        }

      }
    }
  };
}
//# sourceMappingURL=extract.js.map