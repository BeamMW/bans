{"version":3,"file":"templateProcessor.js","names":["units","getTagProcessor","isSerializable","stripLines","toCSS","unwrapNode","unitRegex","RegExp","join","hasMeta","value","processedPaths","WeakSet","dedupInterpolations","interpolations","interpolationsObj","replacements","forEach","it","key","source","unit","push","id","Object","values","getTemplateProcessor","options","process","path","quasis","expressions","state","valueCache","has","add","tagProcessor","isReferenced","parent","findParent","p","isObjectProperty","isJSXOpeningElement","isVariableDeclarator","get","isIdentifier","referencePaths","scope","getBinding","node","name","length","cssText","queue","i","el","expressionValue","self","appended","cooked","matches","match","last","lastInterpolation","endsWith","replace","ex","originalEx","exNode","end","loc","beforeLength","next","start","line","column","__linaria","className","original","expression","addInterpolation","e","Error","buildCodeFrameError","message","uniqInterpolations","s","r","rules","classes","extractRules","replacement","isPure","getRuntimeReplacement","replaceWith","addComment","includes"],"sources":["../../src/evaluators/templateProcessor.ts"],"sourcesContent":["/**\n * This file handles transforming template literals to class names or styled components and generates CSS content.\n * It uses CSS code from template literals and evaluated values of lazy dependencies stored in ValueCache.\n */\n\nimport { NodePath } from '@babel/traverse';\nimport type { TemplateElement } from '@babel/types';\n\nimport type { StyledMeta } from '@linaria/core';\nimport type { IInterpolation } from '@linaria/core/processors/types';\n\nimport type {\n  ExpressionValue,\n  State,\n  StrictOptions,\n  TemplateExpression,\n  ValueCache,\n} from '../types';\nimport { units } from '../units';\nimport getTagProcessor from '../utils/getTagProcessor';\nimport isSerializable from '../utils/isSerializable';\nimport stripLines from '../utils/stripLines';\nimport toCSS from '../utils/toCSS';\nimport unwrapNode from '../utils/unwrapNode';\n\n// Match any valid CSS units followed by a separator such as ;, newline etc.\nconst unitRegex = new RegExp(`^(${units.join('|')})(;|,|\\n| |\\\\))`);\n\nfunction hasMeta(value: unknown): value is StyledMeta {\n  return typeof value === 'object' && value !== null && '__linaria' in value;\n}\n\nconst processedPaths = new WeakSet();\n\n/**\n * De-duplicate interpolations based on the source and unit\n * If two interpolations have the same source code and same unit,\n * we don't need to use 2 custom properties for them, we can use a single one\n * @param interpolations\n */\nfunction dedupInterpolations(\n  interpolations: IInterpolation[]\n): [interpolations: IInterpolation[], replacements: [string, string][]] {\n  const interpolationsObj: Record<string, IInterpolation> = {};\n  const replacements: [string, string][] = [];\n\n  interpolations.forEach((it) => {\n    const key = it.source + it.unit;\n\n    if (key in interpolationsObj) {\n      replacements.push([\n        `var(--${it.id})`,\n        `var(--${interpolationsObj[key].id})`,\n      ]);\n    } else {\n      interpolationsObj[key] = it;\n    }\n  });\n\n  return [Object.values(interpolationsObj), replacements];\n}\n\nexport default function getTemplateProcessor(options: StrictOptions) {\n  return function process(\n    { path, quasis, expressions }: TemplateExpression,\n    state: State,\n    valueCache: ValueCache\n  ) {\n    if (processedPaths.has(path)) {\n      // Do not process an expression\n      // if it is referenced in one template more than once\n      return;\n    }\n\n    processedPaths.add(path);\n\n    const tagProcessor = getTagProcessor(path, state, options);\n    if (!tagProcessor) {\n      return;\n    }\n\n    // Check if the variable is referenced anywhere for basic DCE\n    // Only works when it's assigned to a variable\n    let isReferenced = true;\n\n    const parent = path.findParent(\n      (p) =>\n        p.isObjectProperty() ||\n        p.isJSXOpeningElement() ||\n        p.isVariableDeclarator()\n    );\n\n    if (parent) {\n      if (parent.isVariableDeclarator()) {\n        const id = parent.get('id');\n        if (id.isIdentifier()) {\n          const { referencePaths } = path.scope.getBinding(id.node.name) || {\n            referencePaths: [],\n          };\n\n          isReferenced = referencePaths.length !== 0;\n        }\n      }\n    }\n\n    // Serialize the tagged template literal to a string\n    let cssText = '';\n\n    const { length } = quasis;\n    const queue: [TemplateElement, ExpressionValue | null][] = [];\n    for (let i = 0; i < length; i++) {\n      const value = i < length - 1 ? expressions[i] : null;\n      queue.push([quasis[i].node, value]);\n    }\n\n    queue.forEach(([el, expressionValue], i, self) => {\n      let appended = false;\n\n      if (i !== 0 && el.value.cooked) {\n        // Check if previous expression was a CSS variable that we replaced\n        // If it has a unit after it, we need to move the unit into the interpolation\n        // e.g. `var(--size)px` should actually be `var(--size)`\n        // So we check if the current text starts with a unit, and add the unit to the previous interpolation\n        // Another approach would be `calc(var(--size) * 1px), but some browsers don't support all units\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=956573\n        const matches = el.value.cooked.match(unitRegex);\n\n        if (matches) {\n          const last = tagProcessor.lastInterpolation;\n          const [, unit] = matches;\n\n          if (last && cssText.endsWith(`var(--${last.id})`)) {\n            last.unit = unit;\n            cssText += el.value.cooked.replace(unitRegex, '$2');\n            appended = true;\n          }\n        }\n      }\n\n      if (!appended) {\n        cssText += el.value.cooked;\n      }\n\n      if (expressionValue) {\n        const ex =\n          'originalEx' in expressionValue\n            ? expressionValue.originalEx\n            : expressionValue.ex;\n        const exNode = unwrapNode(ex);\n\n        const { end } = exNode.loc!;\n        const beforeLength = cssText.length;\n\n        // The location will be end of the current string to start of next string\n        const next = self[i + 1]?.[0];\n        const loc = {\n          // +1 because the expressions location always shows 1 column before\n          start: { line: el.loc!.end.line, column: el.loc!.end.column + 1 },\n          end: next\n            ? { line: next.loc!.start.line, column: next.loc!.start.column }\n            : { line: end.line, column: end.column + 1 },\n        };\n\n        const value = valueCache.get(exNode);\n\n        if (value && typeof value !== 'function') {\n          // Skip the blank string instead of throw ing an error\n          if (value === '') {\n            return;\n          }\n\n          if (hasMeta(value)) {\n            // If it's an React component wrapped in styled, get the class name\n            // Useful for interpolating components\n            cssText += `.${value.__linaria.className}`;\n          } else if (isSerializable(value)) {\n            // If it's a plain object or an array, convert it to a CSS string\n            cssText += stripLines(loc, toCSS(value));\n          } else {\n            // For anything else, assume it'll be stringified\n            cssText += stripLines(loc, value);\n          }\n\n          state.replacements.push({\n            original: loc,\n            length: cssText.length - beforeLength,\n          });\n\n          return;\n        }\n\n        try {\n          const { ex: expression } = expressionValue;\n          cssText += tagProcessor.addInterpolation(\n            'node' in expression ? expression.node : expression,\n            expressionValue.source\n          );\n        } catch (e) {\n          if (e instanceof Error && 'buildCodeFrameError' in ex) {\n            throw ex.buildCodeFrameError(e.message);\n          }\n\n          throw e;\n        }\n      }\n    });\n\n    const [uniqInterpolations, replacements] = dedupInterpolations(\n      tagProcessor.interpolations\n    );\n\n    replacements.forEach(([s, r]) => {\n      cssText = cssText.replace(s, r);\n    });\n\n    const [rules, classes] = tagProcessor.extractRules(\n      valueCache,\n      cssText,\n      path.parent?.loc\n    );\n\n    const [replacement, isPure] = tagProcessor.getRuntimeReplacement(\n      classes,\n      uniqInterpolations\n    );\n\n    path.replaceWith(replacement);\n    if (isPure) {\n      path.addComment('leading', '#__PURE__');\n    }\n\n    if (!isReferenced && !cssText.includes(':global')) {\n      return;\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    state.rules = {\n      ...state.rules,\n      ...rules,\n    };\n  };\n}\n"],"mappings":"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"}