{"version":3,"sources":["../src/types.ts"],"names":["ValueType"],"mappings":"AAiBA,WAAYA,SAAZ;;WAAYA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;GAAAA,S,KAAAA,S","sourcesContent":["import type { Node, Expression, TaggedTemplateExpression } from '@babel/types';\nimport type { TransformOptions } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type { StyledMeta } from '@linaria/core';\nimport type { RawSourceMap } from 'source-map';\nimport type { PluginOptions } from './utils/loadOptions';\n\nexport type JSONValue = string | number | boolean | JSONObject | JSONArray;\n\nexport interface JSONObject {\n  [x: string]: JSONValue;\n}\n\nexport interface JSONArray extends Array<JSONValue> {}\n\nexport type Serializable = JSONArray | JSONObject;\n\nexport enum ValueType {\n  COMPONENT,\n  LAZY,\n  FUNCTION,\n  VALUE,\n}\n\nexport type Value = Function | StyledMeta | string | number;\n\nexport type ValueCache = Map<Expression | string, Value>;\n\nexport type ComponentValue = {\n  kind: ValueType.COMPONENT;\n  ex: NodePath<Expression> | Expression | string;\n};\n\nexport type LazyValue = {\n  kind: ValueType.LAZY;\n  ex: NodePath<Expression> | Expression | string;\n  originalEx: NodePath<Expression> | Expression | string;\n};\n\nexport type FunctionValue = {\n  kind: ValueType.FUNCTION;\n  ex: any;\n};\n\nexport type EvaluatedValue = {\n  kind: ValueType.VALUE;\n  value: Value;\n};\n\nexport type ExpressionValue =\n  | ComponentValue\n  | LazyValue\n  | FunctionValue\n  | EvaluatedValue;\n\nexport type TemplateExpression = {\n  styled?: { component: any };\n  path: NodePath<TaggedTemplateExpression>;\n  expressionValues: ExpressionValue[];\n};\n\ntype Rules = {\n  [selector: string]: {\n    className: string;\n    displayName: string;\n    cssText: string;\n    start: Location | null | undefined;\n    atom?: boolean;\n  };\n};\n\ntype Replacements = Array<{\n  original: {\n    start: Location;\n    end: Location;\n  };\n  length: number;\n}>;\n\ntype Dependencies = string[];\n\nexport type State = {\n  queue: TemplateExpression[];\n  rules: Rules;\n  replacements: Replacements;\n  index: number;\n  dependencies: Dependencies;\n  file: {\n    opts: {\n      cwd: string;\n      root: string;\n      filename: string;\n    };\n    metadata: {\n      localName?: string;\n      linaria?: {\n        rules: Rules;\n        replacements: Replacements;\n        dependencies: Dependencies;\n      };\n    };\n  };\n};\n\nexport type Evaluator = (\n  filename: string,\n  options: StrictOptions,\n  text: string,\n  only: string[] | null\n) => [string, Map<string, string[]> | null];\n\nexport type EvalRule = {\n  test?: RegExp | ((path: string) => boolean);\n  action: Evaluator | 'ignore' | string;\n};\n\nexport type ClassNameSlugVars = {\n  hash: string;\n  title: string;\n  file: string;\n  ext: string;\n  name: string;\n  dir: string;\n};\n\ntype ClassNameFn = (\n  hash: string,\n  title: string,\n  args: ClassNameSlugVars\n) => string;\n\ntype AtomizeFn = (cssText: string) => {\n  className: string;\n  cssText: string;\n  property: string;\n}[];\n\nexport type StrictOptions = {\n  classNameSlug?: string | ClassNameFn;\n  displayName: boolean;\n  evaluate: boolean;\n  ignore?: RegExp;\n  atomize?: AtomizeFn;\n  babelOptions: TransformOptions;\n  rules: EvalRule[];\n};\n\nexport type Location = {\n  line: number;\n  column: number;\n};\n\nexport type Replacement = {\n  original: { start: Location; end: Location };\n  length: number;\n};\n\nexport type Result = {\n  code: string;\n  sourceMap?: RawSourceMap | null;\n  cssText?: string;\n  cssSourceMapText?: string;\n  dependencies?: string[];\n  rules?: Rules;\n  replacements?: Replacement[];\n};\n\nexport type LinariaMetadata = {\n  rules: Rules;\n  replacements: Replacement[];\n  dependencies: string[];\n};\n\nexport type Options = {\n  filename: string;\n  preprocessor?: Preprocessor;\n  outputFilename?: string;\n  inputSourceMap?: RawSourceMap;\n  pluginOptions?: Partial<PluginOptions>;\n};\n\nexport type PreprocessorFn = (selector: string, cssText: string) => string;\nexport type Preprocessor = 'none' | 'stylis' | PreprocessorFn | void;\n\ntype AllNodes = { [T in Node['type']]: Extract<Node, { type: T }> };\n\ndeclare module '@babel/types' {\n  type VisitorKeys = {\n    [T in keyof AllNodes]: Extract<\n      keyof AllNodes[T],\n      {\n        [Key in keyof AllNodes[T]]: AllNodes[T][Key] extends\n          | Node\n          | Node[]\n          | null\n          ? Key\n          : never;\n      }[keyof AllNodes[T]]\n    >;\n  };\n}\n"],"file":"types.js"}