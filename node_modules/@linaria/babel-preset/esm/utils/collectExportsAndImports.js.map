{"version":3,"file":"collectExportsAndImports.js","names":["dirname","warn","isRequire","safeResolve","name","filename","require","resolve","paths","e","getValue","node","type","value","isExportKindIsValue","p","exportKind","isImportKindIsValue","importKind","collectors","ImportSpecifier","path","imported","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","collectFromImportDeclaration","state","source","forEach","specifier","isImportSpecifier","collector","imports","push","map","item","whatIsDestructed","destructedProps","properties","property","isObjectProperty","key","isIdentifier","isStringLiteral","what","as","isRestElement","arg","fromVariableDeclarator","isSync","id","isObjectPattern","collectFromDynamicImport","parentPath","callExpression","isCallExpression","sourcePath","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getImportTypeByInteropFunction","callee","undefined","startsWith","collectFromRequire","variableDeclarator","isMemberExpression","unfoldNamespaceImports","result","importItem","binding","scope","getBinding","referenced","referencePath","referencePaths","isExportSpecifier","collectFromExportSpecifier","exported","exports","collectFromExportNamedDeclaration","specifiers","declaration","isVariableDeclaration","declarator","cache","WeakMap","collectExportsAndImports","has","traverse","ExportNamedDeclaration","ImportDeclaration","Import","Identifier","set"],"sources":["../../src/utils/collectExportsAndImports.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax,no-continue */\nimport { dirname } from 'path';\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  CallExpression,\n  ExportNamedDeclaration,\n  ExportSpecifier,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectPattern,\n  StringLiteral,\n  VariableDeclarator,\n  ExportDefaultSpecifier,\n  ExportNamespaceSpecifier,\n} from '@babel/types';\n\nimport { warn } from '@linaria/logger';\n\nimport isRequire from './isRequire';\n\ninterface IImportSpecifier {\n  imported: string | '=' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n}\n\nexport interface IImport extends IImportSpecifier {\n  source: string;\n}\n\nexport interface IExport {\n  exported: string;\n  local: NodePath;\n}\n\nexport interface IState {\n  imports: IImport[];\n  exports: IExport[];\n  filename: string;\n}\n\nconst safeResolve = (name: string, filename: string): string => {\n  try {\n    return require.resolve(name, {\n      paths: [dirname(filename)],\n    });\n  } catch (e: unknown) {\n    return name;\n  }\n};\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We only need value imports. Type imports can be ignored.\nconst isExportKindIsValue = <\n  T extends { node: { exportKind?: 'value' | unknown } }\n>(\n  p: T\n): p is T & { node: { exportKind: 'value' } } =>\n  !p.node.exportKind || p.node.exportKind === 'value';\n\n// We only need value exports. Type exports can be ignored.\nconst isImportKindIsValue = <\n  T extends { node: { importKind?: 'value' | unknown } }\n>(\n  p: T\n): p is T & { node: { importKind: 'value' } } =>\n  !p.node.importKind || p.node.importKind === 'value';\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>\n  ) => IImportSpecifier[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>): IImportSpecifier[] {\n    if (!isImportKindIsValue(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>\n  ): IImportSpecifier[] {\n    const local = path.get('local');\n    return [{ imported: '=', local }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>\n  ): IImportSpecifier[] {\n    const local = path.get('local');\n    return [{ imported: '*', local }];\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: IState\n): void {\n  // If importKind is specified, and it's not a value, ignore that import\n  if (!isImportKindIsValue(path)) return;\n\n  const source = safeResolve(getValue(path.get('source')), state.filename);\n  path\n    .get('specifiers')\n    .forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n      if (specifier.isImportSpecifier() && !isImportKindIsValue(specifier))\n        return;\n\n      const collector = collectors[\n        specifier.node.type\n      ] as typeof collectors[T['type']];\n\n      state.imports.push(\n        ...collector(specifier).map((item) => ({ ...item, source }))\n      );\n    });\n}\n\ninterface IDestructed {\n  what: string | '*';\n  as: NodePath<Identifier | MemberExpression>;\n}\n\nfunction whatIsDestructed(path: NodePath<ObjectPattern>): IDestructed[] {\n  const destructedProps: IDestructed[] = [];\n  const properties = path.get('properties');\n  properties.forEach((property) => {\n    if (property.isObjectProperty()) {\n      const key = property.get('key');\n      if (!key.isIdentifier() && !key.isStringLiteral()) return;\n      const what = getValue(key);\n\n      const as = property.get('value');\n      if (!as.isIdentifier()) return;\n\n      destructedProps.push({ what, as });\n\n      return;\n    }\n\n    // If it is not an ObjectProperty, it is a RestElement\n    // In such case it is the same as importing the whole namespace\n    if (property.isRestElement()) {\n      const arg = property.get('argument');\n      if (!arg.isIdentifier()) {\n        // some unexpected type of argument\n        return;\n      }\n\n      destructedProps.push({\n        as: arg,\n        what: '*',\n      });\n\n      return;\n    }\n\n    warn(\n      'evaluator:collectExportsAndImports',\n      'Unknown type of property:',\n      property.node.type\n    );\n  });\n\n  return destructedProps;\n}\n\nfunction fromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    warn('evaluator:collectExportsAndImports', '`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction collectFromDynamicImport(path: NodePath<Import>, state: IState): void {\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = safeResolve(sourcePath.node.value, state.filename);\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    fromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction getImportTypeByInteropFunction(\n  path: NodePath<CallExpression>\n): '*' | '=' | undefined {\n  const callee = path.get('callee');\n  if (!callee.isIdentifier()) {\n    return undefined;\n  }\n\n  const { name } = callee.node;\n  if (name.startsWith('_interopRequireDefault')) {\n    return '=';\n  }\n\n  if (name.startsWith('_interopRequireWildcard')) {\n    return '*';\n  }\n\n  if (name.startsWith('__rest')) {\n    return '*';\n  }\n\n  return undefined;\n}\n\nfunction collectFromRequire(path: NodePath<Identifier>, state: IState): void {\n  if (!isRequire(path)) return;\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = safeResolve(sourcePath.node.value, state.filename);\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression() && key === 0) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportTypeByInteropFunction(container);\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unknown wrapper of require',\n        container.node.callee\n      );\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unexpected require inside',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Id should be Identifier',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    state.imports.push({\n      imported,\n      local: id,\n      source,\n    });\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Property should be Identifier or StringLiteral',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n        });\n      } else {\n        warn(\n          'evaluator:collectExportsAndImports',\n          'Id should be Identifier',\n          variableDeclarator.node.type\n        );\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    fromVariableDeclarator(container, true).map((prop) =>\n      state.imports.push({ imported: prop.what, local: prop.as, source })\n    );\n  }\n}\n\nfunction unfoldNamespaceImports(imports: IImport[]): IImport[] {\n  const result: IImport[] = [];\n  for (const importItem of imports) {\n    if (importItem.imported === '*') {\n      const { local } = importItem;\n      if (!local.isIdentifier()) {\n        // TODO: handle it\n        result.push(importItem);\n        continue;\n      }\n\n      const binding = local.scope.getBinding(local.node.name);\n      if (!binding?.referenced) {\n        // Imported namespace is not referenced and probably not used,\n        // but it can have side effects, so we should keep it as is\n        result.push(importItem);\n        continue;\n      }\n\n      for (const referencePath of binding?.referencePaths ?? []) {\n        const { parentPath } = referencePath;\n        if (\n          parentPath?.isMemberExpression() &&\n          referencePath.key === 'object'\n        ) {\n          const property = parentPath.get('property');\n          if (property.isIdentifier()) {\n            const { name } = property.node;\n            result.push({\n              ...importItem,\n              imported: name === 'default' ? '=' : name,\n              local: parentPath, // TODO: try to resolve identifier\n            });\n\n            continue;\n          }\n\n          // Otherwise, we can't predict usage and import it as is\n          result.push(importItem);\n          break;\n        }\n\n        if (\n          parentPath?.isVariableDeclarator() &&\n          referencePath.key === 'init'\n        ) {\n          fromVariableDeclarator(parentPath, true).map((prop) =>\n            result.push({ ...importItem, imported: prop.what, local: prop.as })\n          );\n\n          continue;\n        }\n\n        if (parentPath?.isExportSpecifier()) {\n          // The whole namespace is re-exported\n          result.push(importItem);\n          break;\n        }\n\n        // Otherwise, we can't predict usage and import it as is\n        // TODO: handle more cases\n        warn(\n          'evaluator:unfoldNamespaceImports',\n          'Unknown reference',\n          referencePath.node.type\n        );\n        result.push(importItem);\n        break;\n      }\n    } else {\n      result.push(importItem);\n    }\n  }\n\n  return result;\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  state: IState\n): void {\n  if (path.isExportSpecifier()) {\n    const local = path.get('local');\n    const exported = getValue(path.get('exported'));\n    state.exports.push({ local, exported });\n    return;\n  }\n\n  // TODO: handle other cases\n  warn(\n    'evaluator:collectExportsAndImports',\n    'Unprocessed ExportSpecifier',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: IState\n): void {\n  if (!isExportKindIsValue(path)) return;\n\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      fromVariableDeclarator(declarator, true).forEach((prop) => {\n        // What is defined\n        state.exports.push({ exported: prop.what, local: prop.as });\n      });\n    });\n  }\n}\n\nconst cache = new WeakMap<NodePath, IState>();\n\nexport default function collectExportsAndImports(\n  path: NodePath,\n  filename: string\n): IState {\n  const state: IState = {\n    imports: [],\n    exports: [],\n    filename,\n  };\n\n  if (cache.has(path)) {\n    return cache.get(path) ?? state;\n  }\n\n  path.traverse(\n    {\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequire,\n    },\n    state\n  );\n\n  state.imports = unfoldNamespaceImports(state.imports);\n\n  cache.set(path, state);\n\n  return state;\n}\n"],"mappings":"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"}