import type { TransformOptions } from '@babel/core';
import type { NodePath } from '@babel/traverse';
import type { Expression, TaggedTemplateExpression, TemplateElement } from '@babel/types';
import type { RawSourceMap } from 'source-map';
import type { Value } from '@linaria/core/processors/types';
import type { ClassNameFn } from '@linaria/core/processors/utils/types';
import type { PluginOptions } from './utils/loadOptions';
export type { JSONValue, JSONObject, JSONArray, Serializable, Value, ValueCache, } from '@linaria/core/processors/types';
export declare enum ValueType {
    LAZY = 0,
    FUNCTION = 1,
    VALUE = 2
}
export declare type ComponentDependency = {
    ex: NodePath<Expression>;
    source: string;
    value?: string;
};
export declare type LazyValue = {
    kind: ValueType.LAZY;
    ex: NodePath<Expression> | Expression;
    originalEx: NodePath<Expression>;
    source: string;
};
export declare type FunctionValue = {
    kind: ValueType.FUNCTION;
    ex: NodePath<Expression>;
    source: string;
};
export declare type EvaluatedValue = {
    kind: ValueType.VALUE;
    value: Value;
    ex: NodePath<Expression>;
    source: string;
};
export declare type ExpressionValue = LazyValue | FunctionValue | EvaluatedValue;
export declare type Path = NodePath<TaggedTemplateExpression>;
export declare type TemplateExpression = {
    path: Path;
    quasis: NodePath<TemplateElement>[];
    expressions: ExpressionValue[];
    dependencies: ComponentDependency[];
};
export interface ICSSRule {
    className: string;
    displayName: string;
    cssText: string;
    start: Location | null | undefined;
    atom?: boolean;
}
export declare type Rules = Record<string, ICSSRule>;
declare type Replacements = Array<{
    original: {
        start: Location;
        end: Location;
    };
    length: number;
}>;
declare type Dependencies = string[];
export declare type State = {
    queue: TemplateExpression[];
    rules: Rules;
    replacements: Replacements;
    index: number;
    dependencies: Dependencies;
    file: {
        opts: {
            cwd: string;
            root: string;
            filename: string;
        };
        metadata: {
            linaria?: {
                rules: Rules;
                replacements: Replacements;
                dependencies: Dependencies;
            };
        };
    };
};
export declare type Evaluator = (filename: string, options: StrictOptions, text: string, only: string[] | null) => [string, Map<string, string[]> | null];
export declare type EvalRule = {
    test?: RegExp | ((path: string) => boolean);
    action: Evaluator | 'ignore' | string;
};
export declare type LibResolverFn = (linariaLibPath: string) => string | null;
export declare type StrictOptions = {
    classNameSlug?: string | ClassNameFn;
    displayName: boolean;
    evaluate: boolean;
    ignore?: RegExp;
    babelOptions: TransformOptions;
    rules: EvalRule[];
};
export declare type Location = {
    line: number;
    column: number;
};
export declare type Replacement = {
    original: {
        start: Location;
        end: Location;
    };
    length: number;
};
export declare type Result = {
    code: string;
    sourceMap?: RawSourceMap | null;
    cssText?: string;
    cssSourceMapText?: string;
    dependencies?: string[];
    rules?: Rules;
    replacements?: Replacement[];
};
export declare type LinariaMetadata = {
    rules: Rules;
    replacements: Replacement[];
    dependencies: string[];
};
export declare type Options = {
    filename: string;
    preprocessor?: Preprocessor;
    outputFilename?: string;
    inputSourceMap?: RawSourceMap;
    pluginOptions?: Partial<PluginOptions>;
};
export declare type PreprocessorFn = (selector: string, cssText: string) => string;
export declare type Preprocessor = 'none' | 'stylis' | PreprocessorFn | void;
