{"version":3,"sources":["../src/index.ts"],"names":["GenerateClassNames","DetectStyledImportName","JSXElement","ProcessStyled","ProcessCSS","isHoistableExport","node","isVariableDeclaration","kind","declarations","get","Array","isArray","length","init","isCallExpression","callee","isIdentifier","name","scope","hasReference","index","babel","options","visitor","Program","enter","path","state","queue","rules","dependencies","replacements","traverse","ImportDeclaration","p","TaggedTemplateExpression","exit","filter","forEach","remove","unshiftContainer","CallExpression","preset","context","plugins"],"mappings":"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","sourcesContent":["/**\n * This file is a babel preset used to transform files inside evaluators.\n * It works the same as main `babel/extract` preset, but do not evaluate lazy dependencies.\n */\nimport type { NodePath } from '@babel/traverse';\nimport type { Program, Statement, VariableDeclaration } from '@babel/types';\nimport type { State, StrictOptions } from '@linaria/babel-preset';\nimport {\n  GenerateClassNames,\n  DetectStyledImportName,\n  JSXElement,\n  ProcessStyled,\n  ProcessCSS,\n} from '@linaria/babel-preset';\nimport { Core } from './babel';\n\nconst isHoistableExport = (\n  node: NodePath<Statement>\n): node is NodePath<Statement> & NodePath<VariableDeclaration> => {\n  // Only `var` can be hoisted\n  if (!node.isVariableDeclaration({ kind: 'var' })) return false;\n\n  const declarations = node.get('declarations');\n\n  // Our target has only one declaration\n  if (!Array.isArray(declarations) || declarations.length !== 1) return false;\n\n  const init = declarations[0].get('init');\n  // It should be initialized with CallExpression…\n  if (!init || Array.isArray(init) || !init.isCallExpression()) return false;\n\n  const callee = init.get('callee');\n  // … which callee should be `required` …\n  if (Array.isArray(callee) || !callee.isIdentifier({ name: 'require' }))\n    return false;\n\n  // … which should be a global identifier\n  return !callee.scope.hasReference('require');\n};\n\nfunction index(babel: Core, options: StrictOptions) {\n  return {\n    visitor: {\n      Program: {\n        enter(path: NodePath<Program>, state: State) {\n          // Collect all the style rules from the styles we encounter\n          state.queue = [];\n          state.rules = {};\n          state.index = -1;\n          state.dependencies = [];\n          state.replacements = [];\n\n          // We need our transforms to run before anything else\n          // So we traverse here instead of a in a visitor\n          path.traverse({\n            ImportDeclaration: (p) => DetectStyledImportName(babel, p, state),\n            TaggedTemplateExpression: (p) =>\n              GenerateClassNames(babel, p, state, options),\n            JSXElement,\n          });\n        },\n        exit(path: NodePath<Program>) {\n          /* A really dirty hack that solves https://github.com/callstack/linaria/issues/800\n           * Sometimes babel inserts `require` after usages of required modules.\n           * It makes the shaker sad. As a temporary solution, we hoist requires.\n           * This hack should be deleted after transition `shaker` to @babel/traverse\n           */\n          path\n            .get('body')\n            .filter(isHoistableExport)\n            .forEach((p) => {\n              const node = p.node;\n              p.remove();\n              path.unshiftContainer('body', node);\n            });\n        },\n      },\n      CallExpression: ProcessStyled,\n      TaggedTemplateExpression: ProcessCSS, // TaggedTemplateExpression is processed before CallExpression\n    },\n  };\n}\n\nexport default function preset(context: any, options: StrictOptions) {\n  return {\n    plugins: [[index, options]],\n  };\n}\n"],"file":"index.js"}