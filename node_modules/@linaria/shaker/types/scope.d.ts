import { types as t } from '@babel/core';
declare type Scope = Map<string, Set<t.Identifier | t.MemberExpression>>;
export declare type ScopeId = number | 'global' | 'exports';
export declare type DeclareHandler = (identifier: t.Identifier, from: t.Identifier | null) => void;
declare const ResolvedNode: unique symbol;
export declare class PromisedNode<T = t.Node> {
    static is<TNode>(obj: any): obj is PromisedNode<TNode>;
    [ResolvedNode]: T | undefined;
    get identifier(): T | undefined;
}
export declare const resolveNode: <T = t.Node>(obj: T | PromisedNode<T> | undefined) => T | undefined;
export default class ScopeManager {
    static globalExportsIdentifier: t.Identifier;
    static globalModuleIdentifier: t.Identifier;
    private nextId;
    private readonly stack;
    private readonly map;
    private readonly handlers;
    private readonly declarations;
    private get global();
    constructor();
    new(isFunction: boolean, scopeId?: ScopeId): Scope;
    dispose(): Scope | undefined;
    declare(identifierOrMemberExpression: t.Identifier | t.MemberExpression, isHoistable: boolean, from?: t.Identifier | null, stack?: number): void;
    addReference(identifierOrMemberExpression: t.Identifier | t.MemberExpression): t.Identifier | t.MemberExpression | PromisedNode;
    whereIsDeclared(identifier: t.Identifier): ScopeId | undefined;
    getDeclaration(identifierOrMemberExpOrName: t.Identifier | t.MemberExpression | string): t.Identifier | t.MemberExpression | undefined;
    addDeclareHandler(handler: DeclareHandler): () => void;
}
export {};
