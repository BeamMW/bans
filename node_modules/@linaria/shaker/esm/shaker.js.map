{"version":3,"sources":["../src/shaker.ts"],"names":["generator","debug","isNode","getVisitorKeys","build","dumpNode","shakeNode","node","alive","keys","changes","isNodeAlive","n","has","key","subNode","Array","isArray","list","hasChanges","i","length","child","isAlive","shaken","push","undefined","Object","isDefined","shake","rootPath","exports","join","code","depsGraph","Set","reexports","deps","map","token","getLeaves","filter","getLeaf","reduce","acc","el","forEach","d","add","getDependencies","imports","Map","source","members","entries","importType","importTypes","get","defaultMembers","aliveMembers","type","name","value","set","size","from"],"mappings":"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","sourcesContent":["import type { Node, Program } from '@babel/types';\nimport generator from '@babel/generator';\nimport { debug } from '@linaria/logger';\nimport { isNode, getVisitorKeys } from '@linaria/babel-preset';\nimport build from './graphBuilder';\nimport dumpNode from './dumpNode';\n\n/*\n * Returns new tree without dead nodes\n */\nfunction shakeNode<TNode extends Node>(node: TNode, alive: Set<Node>): Node {\n  const keys = getVisitorKeys(node) as Array<keyof TNode>;\n  const changes: Partial<TNode> = {};\n  const isNodeAlive = (n: Node) => alive.has(n);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      const list: any = [];\n      let hasChanges = false;\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        const isAlive = isNodeAlive(child);\n        hasChanges = hasChanges || !isAlive;\n        if (child && isAlive) {\n          const shaken = shakeNode(child, alive);\n          if (shaken) {\n            list.push(shaken);\n          }\n\n          hasChanges = hasChanges || shaken !== child;\n        }\n      }\n      if (hasChanges) {\n        changes[key] = list;\n      }\n    } else if (isNode(subNode)) {\n      if (isNodeAlive(subNode)) {\n        const shaken = shakeNode(subNode, alive);\n        if (shaken && shaken !== subNode) {\n          changes[key] = shaken as any;\n        }\n      } else {\n        changes[key] = undefined;\n      }\n    }\n  }\n\n  return Object.keys(changes).length ? { ...node, ...changes } : node;\n}\n\nconst isDefined = <T>(i: T | undefined): i is T => i !== undefined;\n\n/*\n * Gets AST and a list of nodes for evaluation\n * Removes unrelated “dead” code.\n * Adds to the end of module export of array of evaluated values or evaluation errors.\n * Returns new AST and an array of external dependencies.\n */\nexport default function shake(\n  rootPath: Program,\n  exports: string[] | null\n): [Program, Map<string, string[]>] {\n  debug(\n    'evaluator:shaker:shake',\n    () =>\n      `source (exports: ${(exports || []).join(', ')}):\\n${\n        generator(rootPath).code\n      }`\n  );\n\n  const depsGraph = build(rootPath);\n  const alive = new Set<Node>();\n  const reexports: string[] = [];\n  let deps = (exports ?? [])\n    .map((token) => {\n      if (token === '*') {\n        return depsGraph.getLeaves(null).filter(isDefined);\n      }\n\n      const node = depsGraph.getLeaf(token);\n      if (node) return [node];\n      // We have some unknown token. Do we have `export * from …` in that file?\n      if (depsGraph.reexports.length === 0) {\n        return [];\n      }\n\n      // If so, mark all re-exported files as required\n      reexports.push(token);\n      return [...depsGraph.reexports];\n    })\n    .reduce<Node[]>((acc, el) => {\n      acc.push(...el);\n      return acc;\n    }, []);\n  while (deps.length > 0) {\n    // Mark all dependencies as alive\n    deps.forEach((d) => alive.add(d));\n\n    // Collect new dependencies of dependencies\n    deps = depsGraph.getDependencies(deps).filter((d) => !alive.has(d));\n  }\n\n  const shaken = shakeNode(rootPath, alive) as Program;\n  /*\n   * If we want to know what is really happen with our code tree,\n   * we can print formatted tree here by setting env variable LINARIA_LOG=debug\n   */\n  debug('evaluator:shaker:shake', () => dumpNode(rootPath, alive));\n\n  const imports = new Map<string, string[]>();\n  for (let [source, members] of depsGraph.imports.entries()) {\n    const importType = depsGraph.importTypes.get(source);\n    const defaultMembers = importType === 'wildcard' ? ['*'] : [];\n    const aliveMembers = new Set(\n      members\n        .filter((i) => alive.has(i))\n        .map((i) => (i.type === 'Identifier' ? i.name : i.value))\n    );\n\n    if (importType === 'reexport') {\n      reexports.forEach((token) => aliveMembers.add(token));\n    }\n\n    imports.set(\n      source,\n      aliveMembers.size > 0 ? Array.from(aliveMembers) : defaultMembers\n    );\n  }\n\n  return [shaken, imports];\n}\n"],"file":"shaker.js"}