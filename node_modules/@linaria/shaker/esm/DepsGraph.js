function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { types as t } from '@babel/core';
import { resolveNode } from './scope';

function addEdge(a, b) {
  if (this.dependencies.has(a) && this.dependencies.get(a).has(b)) {
    // edge has been already added∂ƒ
    return;
  }

  this.edges.push([a, b]);

  if (this.dependencies.has(a)) {
    this.dependencies.get(a).add(b);
  } else {
    this.dependencies.set(a, new Set([b]));
  }

  if (this.dependents.has(b)) {
    this.dependents.get(b).add(a);
  } else {
    this.dependents.set(b, new Set([a]));
  }
}

export default class DepsGraph {
  processQueue() {
    if (this.actionQueue.length === 0) {
      return;
    }

    for (const [action, a, b] of this.actionQueue) {
      const resolvedA = resolveNode(a);
      const resolvedB = resolveNode(b);

      if (resolvedA && resolvedB) {
        action.call(this, resolvedA, resolvedB);
      }
    }

    this.actionQueue = [];
  }

  getAllReferences(id) {
    const [, name] = id.split(':');
    const declaration = this.scope.getDeclaration(id);
    const allReferences = [...Array.from(this.dependencies.get(declaration) || []), ...Array.from(this.dependents.get(declaration) || [])].filter(i => t.isIdentifier(i) && i.name === name);
    allReferences.push(declaration);
    return allReferences;
  }

  constructor(scope) {
    this.scope = scope;

    _defineProperty(this, "imports", new Map());

    _defineProperty(this, "importAliases", new Map());

    _defineProperty(this, "importTypes", new Map());

    _defineProperty(this, "reexports", []);

    _defineProperty(this, "parents", new WeakMap());

    _defineProperty(this, "edges", []);

    _defineProperty(this, "exports", new Map());

    _defineProperty(this, "dependencies", new Map());

    _defineProperty(this, "dependents", new Map());

    _defineProperty(this, "actionQueue", []);
  }

  addEdge(dependent, dependency) {
    this.actionQueue.push([addEdge, dependent, dependency]);
  }

  addExport(name, node) {
    const existed = this.exports.get(name);

    if (existed) {
      // Sometimes export can be defined more than once and in that case we have to keep all export statements
      this.addEdge(node, existed);
    }

    this.exports.set(name, node);
  }

  addParent(node, parent) {
    this.parents.set(node, parent);
  }

  getParent(node) {
    return this.parents.get(node);
  }

  getDependenciesByBinding(id) {
    this.processQueue();
    const allReferences = this.getAllReferences(id);
    const dependencies = [];

    for (let [a, b] of this.edges) {
      if (t.isIdentifier(a) && allReferences.includes(a)) {
        dependencies.push(b);
      }
    }

    return dependencies;
  }

  getDependentsByBinding(id) {
    this.processQueue();
    const allReferences = this.getAllReferences(id);
    const dependents = [];

    for (let [a, b] of this.edges) {
      if (t.isIdentifier(b) && allReferences.includes(b)) {
        dependents.push(a);
      }
    }

    return dependents;
  }

  findDependencies(like) {
    this.processQueue();
    return this.edges.filter(([a]) => t.shallowEqual(a, like)).map(([, b]) => b);
  }

  findDependents(like) {
    this.processQueue();
    return this.edges.filter(([, b]) => t.shallowEqual(b, like)).map(([a]) => a);
  }

  getDependencies(nodes) {
    this.processQueue();
    const reduced = [];
    nodes.forEach(n => reduced.push(...Array.from(this.dependencies.get(n) || [])));
    return reduced;
  }

  getLeaf(name) {
    return this.exports.get(name);
  }

  getLeaves(only) {
    this.processQueue();
    return only ? only.map(name => this.getLeaf(name)) : Array.from(this.exports.values());
  }

}
//# sourceMappingURL=DepsGraph.js.map