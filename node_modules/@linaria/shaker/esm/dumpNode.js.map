{"version":3,"sources":["../src/dumpNode.ts"],"names":["types","t","hooks","Identifier","node","name","BinaryExpression","operator","NumericLiteral","value","StringLiteral","isNode","obj","dumpNode","alive","level","idx","result","prefix","repeat","type","has","keys","VISITOR_KEYS","key","subNode","Array","isArray","i","length","child"],"mappings":"AAAA,SAASA,KAAK,IAAIC,CAAlB,QAA2B,aAA3B;AAaA,MAAMC,KAAY,GAAG;AACnBC,EAAAA,UAAU,EAAGC,IAAD,IAAsBA,IAAI,CAACC,IADpB;AAEnBC,EAAAA,gBAAgB,EAAGF,IAAD,IAA4BA,IAAI,CAACG,QAFhC;AAGnBC,EAAAA,cAAc,EAAGJ,IAAD,IAA0BA,IAAI,CAACK,KAH5B;AAInBC,EAAAA,aAAa,EAAGN,IAAD,IAAyBA,IAAI,CAACK;AAJ1B,CAArB;;AAOA,SAASE,MAAT,CAAgBC,GAAhB,EAAuC;AACrC,SAAO,CAAC,CAACA,GAAT;AACD;;AAED,eAAe,SAASC,QAAT,CACbT,IADa,EAEbU,KAAuB,GAAG,IAFb,EAGbC,KAAK,GAAG,CAHK,EAIbC,GAAkB,GAAG,IAJR,EAKb;AACA,MAAIC,MAAM,GAAGF,KAAK,KAAK,CAAV,GAAc,IAAd,GAAqB,EAAlC;AACA,QAAMG,MAAM,GACVH,KAAK,KAAK,CAAV,GACI,EADJ,GAEK,GAAE,KAAKI,MAAL,CAAYJ,KAAK,GAAG,CAApB,CAAuB,GAAEC,GAAG,KAAK,IAAR,GAAe,GAAf,GAAqBA,GAAI,GACnD,CAACA,GAAG,IAAI,CAAR,IAAa,EAAb,GAAkB,GAAlB,GAAwB,EACzB,EALP;AAOA,QAAM;AAAEI,IAAAA;AAAF,MAAWhB,IAAjB;AACAa,EAAAA,MAAM,IAAK,GAAEC,MAAO,GAAEE,IAAK,GAAEA,IAAI,IAAIlB,KAAR,GAAiB,IAAGA,KAAK,CAACkB,IAAD,CAAL,CAAYhB,IAAZ,CAAkB,EAAtC,GAA0C,EAAG,EAA1E;;AAEA,MAAIU,KAAJ,EAAW;AACTG,IAAAA,MAAM,IAAIH,KAAK,CAACO,GAAN,CAAUjB,IAAV,IAAkB,IAAlB,GAAyB,IAAnC;AACD;;AAEDa,EAAAA,MAAM,IAAI,IAAV;AACA,QAAMK,IAAI,GAAGrB,CAAC,CAACsB,YAAF,CAAeH,IAAf,CAAb;;AACA,OAAK,MAAMI,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,UAAMG,OAAO,GAAGrB,IAAI,CAACoB,GAAD,CAApB;AAEAP,IAAAA,MAAM,IAAK,GAAE,KAAKE,MAAL,CAAYJ,KAAZ,CAAmB,KAAIS,GAAI,IAAxC;;AACA,QAAIE,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;AAC1B,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACI,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,cAAME,KAAK,GAAGL,OAAO,CAACG,CAAD,CAArB;AACA,YAAIE,KAAJ,EAAWb,MAAM,IAAIJ,QAAQ,CAACiB,KAAD,EAAQhB,KAAR,EAAeC,KAAK,GAAG,CAAvB,EAA0Ba,CAA1B,CAAlB;AACZ;AACF,KALD,MAKO,IAAIjB,MAAM,CAACc,OAAD,CAAV,EAAqB;AAC1BR,MAAAA,MAAM,IAAIJ,QAAQ,CAACY,OAAD,EAAUX,KAAV,EAAiBC,KAAK,GAAG,CAAzB,CAAlB;AACD;AACF;;AAED,SAAOE,MAAP;AACD","sourcesContent":["import { types as t } from '@babel/core';\nimport type {\n  BinaryExpression,\n  Identifier,\n  Node,\n  NumericLiteral,\n  StringLiteral,\n} from '@babel/types';\n\ntype Hooks = {\n  [key: string]: (node: any) => string | number;\n};\n\nconst hooks: Hooks = {\n  Identifier: (node: Identifier) => node.name,\n  BinaryExpression: (node: BinaryExpression) => node.operator,\n  NumericLiteral: (node: NumericLiteral) => node.value,\n  StringLiteral: (node: StringLiteral) => node.value,\n};\n\nfunction isNode(obj: any): obj is Node {\n  return !!obj;\n}\n\nexport default function dumpNode<T extends Node>(\n  node: T,\n  alive: Set<Node> | null = null,\n  level = 0,\n  idx: number | null = null\n) {\n  let result = level === 0 ? '\\n' : '';\n  const prefix =\n    level === 0\n      ? ''\n      : `${'| '.repeat(level - 1)}${idx === null ? '|' : idx}${\n          (idx || 0) < 10 ? '=' : ''\n        }`;\n\n  const { type } = node;\n  result += `${prefix}${type}${type in hooks ? ` ${hooks[type](node)}` : ''}`;\n\n  if (alive) {\n    result += alive.has(node) ? ' ✅' : ' ❌';\n  }\n\n  result += '\\n';\n  const keys = t.VISITOR_KEYS[type] as Array<keyof T>;\n  for (const key of keys) {\n    const subNode = node[key];\n\n    result += `${'| '.repeat(level)}|-${key}\\n`;\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (child) result += dumpNode(child, alive, level + 2, i);\n      }\n    } else if (isNode(subNode)) {\n      result += dumpNode(subNode, alive, level + 2);\n    }\n  }\n\n  return result;\n}\n"],"file":"dumpNode.js"}