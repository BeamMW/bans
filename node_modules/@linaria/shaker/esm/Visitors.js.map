{"version":3,"sources":["../src/Visitors.ts"],"names":["types","t","warn","peek","identifierHandlers","visitors","core","Identifier","node","parent","parentKey","listIdx","handler","type","kindOfDeclaration","meta","get","scope","declare","declaration","addReference","graph","addEdge","context","name","isKeyOfVisitors","getVisitors","aliases","ALIAS_KEYS","aliasVisitors","map","filter","i","v"],"mappings":"AAAA,SAASA,KAAK,IAAIC,CAAlB,QAA2B,aAA3B;AAEA,SAASC,IAAT,QAAqB,iBAArB;AACA,SAASC,IAAT,QAAqB,uBAArB;AAEA,OAAOC,kBAAP,MAA+B,sBAA/B;AAGA,SAASC,QAAQ,IAAIC,IAArB,QAAiC,cAAjC;AAEA,MAAMD,QAAkB,GAAG;AACzBE,EAAAA,UAAU,CAERC,IAFQ,EAGRC,MAHQ,EAIRC,SAJQ,EAKRC,OAAsB,GAAG,IALjB,EAMR;AACA,QAAI,CAACF,MAAD,IAAW,CAACC,SAAhB,EAA2B;AACzB;AACD;;AAED,UAAME,OAAO,GAAGR,kBAAkB,CAAE,GAAEK,MAAM,CAACI,IAAK,IAAGH,SAAU,EAA7B,CAAlC;;AAEA,QAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;AACjCA,MAAAA,OAAO,CAAC,IAAD,EAAOJ,IAAP,EAAaC,MAAb,EAAqBC,SAArB,EAAgCC,OAAhC,CAAP;AACA;AACD;;AAED,QAAIC,OAAO,KAAK,MAAhB,EAAwB;AACtB;AACD;;AAED,QAAIA,OAAO,KAAK,SAAhB,EAA2B;AACzB,YAAME,iBAAiB,GAAG,KAAKC,IAAL,CAAUC,GAAV,CAAc,qBAAd,CAA1B;AACA,WAAKC,KAAL,CAAWC,OAAX,CAAmBV,IAAnB,EAAyBM,iBAAiB,KAAK,KAA/C,EAAsD,IAAtD;AACA;AACD;;AAED,QAAIF,OAAO,KAAK,OAAhB,EAAyB;AACvB,YAAMO,WAAW,GAAG,KAAKF,KAAL,CAAWG,YAAX,CAAwBZ,IAAxB,CAApB,CADuB,CAEvB;;AACA,UAAIW,WAAJ,EAAiB;AACf;AACA,aAAKE,KAAL,CAAWC,OAAX,CAAmBd,IAAnB,EAAyBW,WAAzB;AAEA,cAAMI,OAAO,GAAGpB,IAAI,CAAC,KAAKoB,OAAN,CAApB;;AACA,YAAIA,OAAO,KAAK,MAAhB,EAAwB;AACtB;AACA,eAAKF,KAAL,CAAWC,OAAX,CAAmBH,WAAnB,EAAgCX,IAAhC;AACD;AACF;;AAED;AACD;AAED;AACJ;AACA;AACA;;;AACIN,IAAAA,IAAI,CACF,kBADE,EAEF,sBAFE,EAGFM,IAAI,CAACgB,IAHH,EAIFf,MAAM,CAACI,IAJL,EAKFH,SALE,EAMFC,OANE,CAAJ;AAQD,GA1DwB;;AA4DzB,KAAGL;AA5DsB,CAA3B;;AA+DA,MAAMmB,eAAe,GAAIZ,IAAD,IACtBA,IAAI,IAAIR,QADV;;AAGA,OAAO,SAASqB,WAAT,CAAyClB,IAAzC,EAAwE;AAC7E,QAAMmB,OAAO,GAAG1B,CAAC,CAAC2B,UAAF,CAAapB,IAAI,CAACK,IAAlB,KAA2B,EAA3C;AACA,QAAMgB,aAAa,GAAGF,OAAO,CAC1BG,GADmB,CACdjB,IAAD,IAAWY,eAAe,CAACZ,IAAD,CAAf,GAAwBR,QAAQ,CAACQ,IAAD,CAAhC,GAAyC,IADrC,EAEnBkB,MAFmB,CAEXC,CAAD,IAAOA,CAFK,CAAtB;AAGA,SAAO,CAAC,GAAGH,aAAJ,EAAmBxB,QAAQ,CAACG,IAAI,CAACK,IAAN,CAA3B,EAA0DkB,MAA1D,CACJE,CAAD,IAAOA,CADF,CAAP;AAGD;AAED,eAAe5B,QAAf","sourcesContent":["import { types as t } from '@babel/core';\nimport type { Identifier, Node, VisitorKeys } from '@babel/types';\nimport { warn } from '@linaria/logger';\nimport { peek } from '@linaria/babel-preset';\nimport GraphBuilderState from './GraphBuilderState';\nimport identifierHandlers from './identifierHandlers';\nimport type { Visitor, Visitors } from './types';\n\nimport { visitors as core } from './langs/core';\n\nconst visitors: Visitors = {\n  Identifier<TParent extends Node>(\n    this: GraphBuilderState,\n    node: Identifier,\n    parent: TParent | null,\n    parentKey: VisitorKeys[TParent['type']] | null,\n    listIdx: number | null = null\n  ) {\n    if (!parent || !parentKey) {\n      return;\n    }\n\n    const handler = identifierHandlers[`${parent.type}:${parentKey}`];\n\n    if (typeof handler === 'function') {\n      handler(this, node, parent, parentKey, listIdx);\n      return;\n    }\n\n    if (handler === 'keep') {\n      return;\n    }\n\n    if (handler === 'declare') {\n      const kindOfDeclaration = this.meta.get('kind-of-declaration');\n      this.scope.declare(node, kindOfDeclaration === 'var', null);\n      return;\n    }\n\n    if (handler === 'refer') {\n      const declaration = this.scope.addReference(node);\n      // Let's check that it's not a global variable\n      if (declaration) {\n        // usage of a variable depends on its declaration\n        this.graph.addEdge(node, declaration);\n\n        const context = peek(this.context);\n        if (context === 'lval') {\n          // This is an identifier in the left side of an assignment expression and a variable value depends on that.\n          this.graph.addEdge(declaration, node);\n        }\n      }\n\n      return;\n    }\n\n    /*\n     * There is an unhandled identifier.\n     * This case should be added to ./identifierHandlers.ts\n     */\n    warn(\n      'evaluator:shaker',\n      'Unhandled identifier',\n      node.name,\n      parent.type,\n      parentKey,\n      listIdx\n    );\n  },\n\n  ...core,\n};\n\nconst isKeyOfVisitors = (type: string): type is keyof Visitors =>\n  type in visitors;\n\nexport function getVisitors<TNode extends Node>(node: TNode): Visitor<TNode>[] {\n  const aliases = t.ALIAS_KEYS[node.type] || [];\n  const aliasVisitors = aliases\n    .map((type) => (isKeyOfVisitors(type) ? visitors[type] : null))\n    .filter((i) => i) as Visitor<TNode>[];\n  return [...aliasVisitors, visitors[node.type] as Visitor<TNode>].filter(\n    (v) => v\n  );\n}\n\nexport default visitors;\n"],"file":"Visitors.js"}