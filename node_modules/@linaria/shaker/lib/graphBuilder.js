"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@babel/core");

var _babelPreset = require("@linaria/babel-preset");

var _GraphBuilderState = _interopRequireDefault(require("./GraphBuilderState"));

var _Visitors = require("./Visitors");

var _scope = _interopRequireDefault(require("./scope"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isVoid = node => _core.types.isUnaryExpression(node) && node.operator === 'void';

function isTSExporterCall(node) {
  if (!_core.types.isCallExpression(node) || node.arguments.length !== 2) {
    return false;
  } // FIXME: more precisely check


  return !(!_core.types.isIdentifier(node.callee) || node.callee.name !== 'exporter');
}

class GraphBuilder extends _GraphBuilderState.default {
  static build(root) {
    return new GraphBuilder(root).graph;
  }

  constructor(rootNode) {
    super();
    this.visit(rootNode, null, null, null);
  }

  isExportsIdentifier(node) {
    if (_core.types.isIdentifier(node)) {
      return this.scope.getDeclaration(node) === _scope.default.globalExportsIdentifier;
    }

    if (_core.types.isMemberExpression(node)) {
      return _core.types.isIdentifier(node.property) && node.property.name === 'exports' && _core.types.isIdentifier(node.object) && this.scope.getDeclaration(node.object) === _scope.default.globalModuleIdentifier;
    }

    return false;
  }

  isExportsAssignment(node) {
    if (node && _core.types.isAssignmentExpression(node) && _core.types.isMemberExpression(node.left)) {
      if (this.isExportsIdentifier(node.left)) {
        // This is a default export like `module.exports = 42`
        return true;
      }

      if (this.isExportsIdentifier(node.left.object)) {
        // This is a named export like `module.exports.a = 42` or `exports.a = 42`
        return true;
      }
    }

    return false;
  }
  /*
   * Implements a default behaviour for AST-nodes:
   * • visits every child;
   * • if the current node is an Expression node, adds all its children as dependencies.
   *
   * eg. BinaryExpression has children `left` and `right`,
   * both of them are required for evaluating the value of the expression
   */


  baseVisit(node, ignoreDeps = false) {
    const dependencies = [];

    const isExpression = _core.types.isExpression(node);

    const keys = (0, _babelPreset.getVisitorKeys)(node);
    keys.forEach(key => {
      // Ignore all types
      if (key === 'typeArguments' || key === 'typeParameters') {
        return;
      }

      const subNode = node[key];

      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];

          if (child && this.visit(child, node, key, i) !== 'ignore') {
            dependencies.push(child);
          }
        }
      } else if ((0, _babelPreset.isNode)(subNode) && this.visit(subNode, node, key) !== 'ignore') {
        dependencies.push(subNode);
      }
    });

    if (isExpression && !ignoreDeps) {
      dependencies.forEach(dep => this.graph.addEdge(node, dep));
    }

    this.callbacks.forEach(callback => callback(node));
  }

  visit(node, parent, parentKey, listIdx = null) {
    if (parent) {
      this.graph.addParent(node, parent);
    }

    if (this.isExportsAssignment(node) && !this.isExportsAssignment(node.right) && !isVoid(node.right)) {
      if (_core.types.isMemberExpression(node.left) && (_core.types.isIdentifier(node.left.property) || _core.types.isStringLiteral(node.left.property))) {
        if (_core.types.isIdentifier(node.left.object) && node.left.object.name === 'module') {
          // It's a batch or default export
          if (_core.types.isObjectExpression(node.right)) {
            // Batch export is a very particular case.
            // Each property of the assigned object is independent named export.
            // We also need to specify all dependencies and call `visit` for every value.
            this.visit(node.left, node, 'left');
            node.right.properties.forEach(prop => {
              if (_core.types.isObjectProperty(prop) && _core.types.isIdentifier(prop.key)) {
                this.visit(prop.value, prop, 'value');
                this.graph.addExport(prop.key.name, prop);
                this.graph.addEdge(prop, node.right);
                this.graph.addEdge(prop, prop.key);
                this.graph.addEdge(prop.key, prop.value);
              }
            });
            this.graph.addEdge(node.right, node);
            this.graph.addEdge(node, node.left);
          } else {
            this.graph.addExport('default', node);
            this.graph.addEdge(node, node.left);
          } // Regardless of whether the node.right is an object expression, this may also be the default export


          this.graph.addExport('default', node);
        } else {
          // it can be either `exports.name` or `exports["name"]`
          const nameNode = node.left.property;
          this.graph.addExport(_core.types.isStringLiteral(nameNode) ? nameNode.value : nameNode.name, node);
        }
      }
    } else if (isTSExporterCall(node)) {
      const [name, identifier] = node.arguments;
      this.graph.addExport(name.value, node);
      this.graph.addEdge(node, identifier);
    } else if (_core.types.isVariableDeclaration(node)) {
      // We might be assigning to the exports, eg. `var Padding = exports.Padding = ...`
      // or it might be a sequence and look like var foo = 1, var Name = exports.name = ...
      node.declarations.forEach(declaration => {
        if (_core.types.isVariableDeclarator(declaration) && _core.types.isAssignmentExpression(declaration.init)) {
          let currentAssignmentExpression = declaration.init;
          let addedExport = false;
          const edgesToAdd = []; // loop through the assignments looking for possible exports

          while (_core.types.isAssignmentExpression(currentAssignmentExpression)) {
            edgesToAdd.push(currentAssignmentExpression);

            if (this.isExportsAssignment(currentAssignmentExpression) && _core.types.isMemberExpression(currentAssignmentExpression.left) && (_core.types.isIdentifier(currentAssignmentExpression.left.property) || _core.types.isStringLiteral(currentAssignmentExpression.left.property))) {
              const nameNode = currentAssignmentExpression.left.property;
              this.graph.addExport(_core.types.isStringLiteral(nameNode) ? nameNode.value : nameNode.name, node);
              addedExport = true;
              edgesToAdd.push(declaration);
              edgesToAdd.push(currentAssignmentExpression.left);
              edgesToAdd.push(currentAssignmentExpression.right);
            }

            currentAssignmentExpression = currentAssignmentExpression.right;
          }

          if (addedExport) {
            edgesToAdd.forEach(edge => {
              this.graph.addEdge(node, edge);
            });
          }
        }
      });
    }

    const isScopable = _core.types.isScopable(node);

    const isFunction = _core.types.isFunction(node);

    if (isScopable) this.scope.new(_core.types.isProgram(node) || _core.types.isFunction(node));
    if (isFunction) this.fnStack.push(node);
    const visitors = (0, _Visitors.getVisitors)(node);
    let action;

    if (visitors.length > 0) {
      let visitor; // eslint-disable-next-line no-cond-assign

      while (!action && (visitor = visitors.shift())) {
        const method = visitor.bind(this);
        action = method(node, parent, parentKey, listIdx);
      }
    } else {
      this.baseVisit(node);
    }

    if (parent && action !== 'ignore' && _core.types.isStatement(node)) {
      // Statement always depends on its parent
      this.graph.addEdge(node, parent);
    }

    if (isFunction) this.fnStack.pop();
    if (isScopable) this.scope.dispose();
    return action;
  }

}

var _default = GraphBuilder.build;
exports.default = _default;
//# sourceMappingURL=graphBuilder.js.map