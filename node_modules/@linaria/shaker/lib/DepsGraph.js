"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@babel/core");

var _scope = require("./scope");

function addEdge(a, b) {
  if (this.dependencies.has(a) && this.dependencies.get(a).has(b)) {
    // edge has been already added∂ƒ
    return;
  }

  this.edges.push([a, b]);

  if (this.dependencies.has(a)) {
    this.dependencies.get(a).add(b);
  } else {
    this.dependencies.set(a, new Set([b]));
  }

  if (this.dependents.has(b)) {
    this.dependents.get(b).add(a);
  } else {
    this.dependents.set(b, new Set([a]));
  }
}

class DepsGraph {
  imports = new Map();
  importAliases = new Map();
  importTypes = new Map();
  reexports = [];
  parents = new WeakMap();
  edges = [];
  exports = new Map();
  dependencies = new Map();
  dependents = new Map();
  actionQueue = [];

  processQueue() {
    if (this.actionQueue.length === 0) {
      return;
    }

    this.actionQueue.forEach(([action, a, b]) => {
      const resolvedA = (0, _scope.resolveNode)(a);
      const resolvedB = (0, _scope.resolveNode)(b);

      if (resolvedA && resolvedB) {
        action.call(this, resolvedA, resolvedB);
      }
    });
    this.actionQueue = [];
  }

  getAllReferences(id) {
    const [, name] = id.split(':');
    const declaration = this.scope.getDeclaration(id);
    const allReferences = [...Array.from(this.dependencies.get(declaration) || []), ...Array.from(this.dependents.get(declaration) || [])].filter(i => _core.types.isIdentifier(i) && i.name === name);
    allReferences.push(declaration);
    return allReferences;
  }

  constructor(scope) {
    this.scope = scope;
  }

  addEdge(dependent, dependency) {
    this.actionQueue.push([addEdge, dependent, dependency]);
  }

  addExport(name, node) {
    const existed = this.exports.get(name);

    if (existed) {
      // Sometimes export can be defined more than once and in that case we have to keep all export statements
      this.addEdge(node, existed);
    }

    this.exports.set(name, node);
  }

  addParent(node, parent) {
    this.parents.set(node, parent);
  }

  getParent(node) {
    return this.parents.get(node);
  }

  getDependenciesByBinding(id) {
    this.processQueue();
    const allReferences = this.getAllReferences(id);
    const dependencies = [];
    this.edges.forEach(([a, b]) => {
      if (_core.types.isIdentifier(a) && allReferences.includes(a)) {
        dependencies.push(b);
      }
    });
    return dependencies;
  }

  getDependentsByBinding(id) {
    this.processQueue();
    const allReferences = this.getAllReferences(id);
    const dependents = [];
    this.edges.forEach(([a, b]) => {
      if (_core.types.isIdentifier(b) && allReferences.includes(b)) {
        dependents.push(a);
      }
    });
    return dependents;
  } // eslint-disable-next-line @typescript-eslint/ban-types


  findDependencies(like) {
    this.processQueue();
    return this.edges.filter(([a]) => _core.types.shallowEqual(a, like)).map(([, b]) => b);
  }

  findDependents(like) {
    this.processQueue();
    return this.edges.filter(([, b]) => _core.types.shallowEqual(b, like)).map(([a]) => a);
  }

  getDependencies(nodes) {
    this.processQueue();
    const reduced = [];
    nodes.forEach(n => reduced.push(...Array.from(this.dependencies.get(n) || [])));
    return reduced;
  }

  getLeaf(name) {
    return this.exports.get(name);
  }

  getLeaves(only) {
    this.processQueue();
    return only ? only.map(name => this.getLeaf(name)) : Array.from(this.exports.values());
  }

}

exports.default = DepsGraph;
//# sourceMappingURL=DepsGraph.js.map