"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineHandler = defineHandler;
exports.batchDefineHandlers = batchDefineHandlers;
exports.default = void 0;

var _core = require("@babel/core");

var _babelPreset = require("@linaria/babel-preset");

var _core2 = require("./langs/core");

var _scope = _interopRequireDefault(require("./scope"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const handlers = {};

function isAlias(type) {
  return type in _core.types.FLIPPED_ALIAS_KEYS;
}

function defineHandler(typeOrAlias, field, handler) {
  const types = isAlias(typeOrAlias) ? _core.types.FLIPPED_ALIAS_KEYS[typeOrAlias] : [typeOrAlias];
  types.forEach(type => {
    handlers[`${type}:${field}`] = handler;
  });
}

function batchDefineHandlers(typesAndFields, handler) {
  typesAndFields.forEach(([type, ...fields]) => fields.forEach(field => defineHandler(type, field, handler)));
}

batchDefineHandlers([..._core2.identifierHandlers.declare], 'declare');
batchDefineHandlers([..._core2.identifierHandlers.keep], 'keep');
batchDefineHandlers([..._core2.identifierHandlers.refer], 'refer');
/*
 * Special case for FunctionDeclaration
 * Function id should be defined in the parent scope
 */

defineHandler('FunctionDeclaration', 'id', (builder, node) => {
  builder.scope.declare(node, false, null, 1);
});
/*
 * Special handler for [obj.member = 42] = [1] in different contexts
 */

const memberExpressionObjectHandler = (builder, node) => {
  const context = (0, _babelPreset.peek)(builder.context);
  const declaration = builder.scope.addReference(node);

  if (declaration) {
    builder.graph.addEdge(node, declaration);

    if (context === 'lval') {
      // One exception here: we shake exports,
      // so `exports` does not depend on its members' assignments.
      if (declaration !== _scope.default.globalExportsIdentifier && declaration !== _scope.default.globalModuleIdentifier) {
        builder.graph.addEdge(declaration, node);
      }
    }
  }
};

defineHandler('MemberExpression', 'object', memberExpressionObjectHandler);
defineHandler('OptionalMemberExpression', 'object', memberExpressionObjectHandler);
/*
 * Special handler for obj.member and obj[member]
 */

const memberExpressionPropertyHandler = (builder, node, parent) => {
  if (_core.types.isMemberExpression(parent) && parent.computed) {
    const declaration = builder.scope.addReference(node); // Let's check that it's not a global variable

    if (declaration) {
      // usage of a variable depends on its declaration
      builder.graph.addEdge(node, declaration);
      const context = (0, _babelPreset.peek)(builder.context);

      if (context === 'lval') {
        // This is an identifier in the left side of an assignment expression and a variable value depends on that.
        builder.graph.addEdge(declaration, node);
      }
    }
  }
};

defineHandler('MemberExpression', 'property', memberExpressionPropertyHandler);
defineHandler('OptionalMemberExpression', 'property', memberExpressionPropertyHandler);
var _default = handlers;
exports.default = _default;
//# sourceMappingURL=identifierHandlers.js.map